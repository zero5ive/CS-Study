# 의존성 주입 (DI) 및 제어의 역전 (IoC)

## 의존성 주입 (Dependency Injection, DI)

**개념**

- **의존한다(Dependency)**: A가 B를 사용할 때, B가 바뀌면 A도 영향을 받는 관계. A->B 로 표시한다.

- **주입(Injection)**: 필요한 객체를 `new`로 직접 만드는 게 아니라, 외부(주입자)로부터 **간접적**으로 받아서 사용하는 것. 메인 모듈은 구체적인 구현체 대신 인터페이스에만 의존하게 되어, 의존성을 주입받는 통로(생성자, 수정자 등)만 열어두면 된다.


**장점**

1. **결합도 완화**: 모듈 간의 의존성을 낮춰 코드 재사용성이 높아지고 쉽게 교체할 수 있다.

2. **테스트 용이성**: 실제 객체 대신 **Mock(가짜 객체)**를 주입하여 단위 테스트를 쉽게 수행할 수 있다.

3. **코드의 일관성**: 객체 생성과 사용의 관심사가 분리된다.


**단점**

1. **복잡도 증가**: 의존 관계를 정의하기 위한 추가적인 클래스나 설정이 추가로 필요하다.

2. **런타임 에러**: 종속성 주입은 런타임 시 일어나므로, 의존성 주입이 잘못될 경우 컴파일 시점이 아니라 프로그램 실행 시점에서 에러가 발생할 수 있다.


#### DI를 적용하지 않은 사례 vs 적용한 사례
- **[비적용] 직접 객체 생성 (강한 결합)**
```java
class Programmer {
    private Keyboard keyboard = new MechanicalKeyboard(); // 직접 생성 (의존성 발생)
}
```

클래스 내부에서 `new` 키워드로 직접 의존 객체를 생성한다. 키보드를 바꾸고 싶다면, `Programmer` 클래스코드를 직접 수정해야 한다.

- **[적용] 생성자 주입 (느슨한 결합)**
```java
interface Keyboard {}
class MechanicalKeyboard implements Keyboard {}

class Programmer {
    private Keyboard keyboard;

    // 외부(주입자)로부터 객체를 받음
    public Programmer(Keyboard keyboard) {
        this.keyboard = keyboard;
    }
}
```

생성자나 수정자(Setter)를 통해 인터페이스 타입을 주입받는다.


## 제어의 역전 (IoC, Inversion of Control)

객체의 생명주기 관리나 흐름 제어권을 개발자가 아닌 **프레임워크(Spring 등)** 가 가져가는 것.

- **Spring의 역할**: 개발자가 `@Service`, `@Repository` 등으로 등록해두면, Spring의 **IoC 컨테이너**가 알아서 **객체(Bean)를 만들고** 필요한 곳에 **주입**한다.

### DIP, DI, IoC의 차이

- **IoC**: 제어의 주체가 누구인가에 대한 가장 상위의 개념.
- [**의존 관계 역전 원칙(DIP)**](https://velog.io/@yejiiiin/SOLID-%EC%84%A4%EA%B3%84-%EC%9B%90%EC%B9%99-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99#5-dip-dependency-inversion-principle-%EC%9D%98%EC%A1%B4-%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99): 추상화에 의존해야 한다는 설계 원칙.
- **DI**: 이 원칙을 실제로 구현하기 위해 외부에서 의존성을 넣어주는 구체적인 디자인 패턴.



# MVC MVP MVVM 패턴
## MVC 패턴
모델, 뷰, 컨트롤러로 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 **관심사 분리**를 실현한 패턴

- **Model (모델)**: 애플리케이션의 데이터와 비즈니스 로직을 담당한다. 
상태 변화가 일어날 때 뷰나 컨트롤러에 대해 직접적인 지식을 가져서는 안 된다. (독립성)

  - 예: DB 데이터, 상수, 변수, 비즈니스 처리 로직

- **View (뷰)**: 사용자에게 보여지는 UI 화면. 
모델의 정보를 직접 저장하지 않으며, 단순히 전달받은 데이터를 출력만 한다.

  - 예: HTML, JSP, React 컴포넌트 등

- **Controller (컨트롤러)**: 모델과 뷰 사이의 중개자. 
사용자의 입력을 받아 해석하고, 모델을 업데이트하거나 뷰를 선택하여 제어 흐름을 관리한다.

**장점**
- UI 개발자와 비즈니스 로직 개발자가 역할을 나누어 동시에 작업할 수 있다.
- 유지보수성이 높다. 각 요소가 분리되어 있어 특정 부분의 수정이 다른 부분에 미치는 영향을 최소화한다.
- 재사용성이 높다. 하나의 모델을 여러 개의 뷰에서 재사용할 수 있습니다.

**단점**
- 복잡한 프로그램일수록 컨트롤러에 비즈니스 로직이 몰려 비대해지는 현상이 발생한다.
- 뷰와 모델 사이의 의존성을 완벽히 제거하기 어렵다. (이를 보완하기 위해 MVP, MVVM 패턴이 등장)

### Spring의 MVC패턴 적용사례
![](https://velog.velcdn.com/images/yejiiiin/post/b2b2188f-b739-4396-ab82-d0b105d2bb30/image.png)

**동작 순서**

1. **핸들러 조회**: HandlerMapping을 통해 URL에 매핑된 컨트롤러(핸들러)를 찾는다.

2. **핸들러 어댑터 조회**: 찾은 핸들러를 실행할 수 있는 HandlerAdapter를 찾는다. 
이 어댑터 덕분에 다양한 형태의 컨트롤러를 사용할 수 있는 유연성이 생긴다.

3. **핸들러 어댑터 실행**: 어댑터가 핸들러를 실행한다.

4. **핸들러(컨트롤러) 실행**: 실제 비즈니스 로직이 수행된다.

5. **ModelAndView 반환**: 핸들러가 반환하는 정보를 어댑터가 ModelAndView로 변환해서 반환한다.

6. **viewResolver 호출**: 뷰 리졸버를 찾아 실행한다. (논리 이름을 물리 이름으로 변환하는 단계)

7. **View 반환**: 렌더링 역할을 담당하는 뷰 객체를 반환한다.

8. **뷰 렌더링**: 모델 데이터를 사용하여 뷰를 렌더링하고 사용자에게 응답합니다.


## MVP 패턴 (Model-View-Presenter)

MVC에서 사용자 입력 처리를 담당하던 컨트롤러(Controller)가 **프레젠터(Presenter)**로 교체된 패턴이다. View와 Model의 완벽한 분리를 목적으로 한다.

- **Presenter (프레젠터)**: 뷰(View)에서 요청한 데이터를 모델(Model)에서 가져와 가공한 뒤 뷰에 전달한다. View의 인터페이스를 참조하여 직접적으로 화면 업데이트를 명령한다.

- 뷰와 프레젠터는 1:1 관계를 맺으며, 뷰와 모델 사이의 직접적인 의존성을 완전히 차단한다.

**장점:**
뷰와 모델의 분리가 확실하여 테스트가 편리하다.

**단점:**
뷰와 프레젠터가 1:1로 강하게 결합되어, 앱이 커질수록 프레젠터가 커지고 코드량이 많아진다.


## MVVM 패턴 (Model-View-ViewModel)

데이터 바인딩 기술을 활용하여 뷰와 로직을 완전히 독립시킨 패턴이다. 
뷰가 뷰모델을 관찰하는 구조이므로, N : 1 (여러 뷰가 하나의 뷰모델 사용) 관계가 가능하다.

- **데이터 바인딩**: 화면의 데이터(View)와 메모리의 데이터(ViewModel)를 실시간으로 동기화하는 기술. 
모델이 변하면 화면이 자동으로 바뀌므로 개발자가 일일이 업데이트 코드를 짤 필요가 없다.

- **커맨드 (Command)**: 여러 요소에 대한 처리를 하나의 액션으로 묶어 뷰모델에 전달하는 기법.

**장점**: 
뷰와 뷰모델 사이의 의존성이 없어 코드 재사용성이 매우 높고, 단위 테스트가 매우 쉽다.

**단점**: 
설계가 복잡하고, 데이터 바인딩 처리를 위한 초기 설정 및 오버헤드가 발생할 수 있다.

- 대표 프레임워크: Vue.js, Angular, Android Jetpack(ViewModel).


| 구분 | MVC | MVP | MVVM |
|------|-----|-----|------|
| 핵심 요소 | Controller | Presenter | ViewModel |
| 요소 간 관계 | 1 : N | 1 : 1 | N : 1 (독립적) |
| 핵심 기술 | 범용적인 제어 | 인터페이스 참조 | 데이터 바인딩 |
| 주요 특징 | 구조가 단순함 | V-M 분리 철저 | 테스트 및 재사용성 최강 |





## flux 패턴
데이터가 한 방향으로만 흐르도록 제어하여 애플리케이션의 복잡도를 낮추는 디자인 패턴이다.

기존 MVC 패턴은 데이터가 양방향으로 흐를 수 있어, 모델과 뷰가 많아지면 어디서 데이터가 변했는지 추적하기가 매우 힘들다. 페이스북의 알림 버그가 대표적인 사례.

**구조**
데이터는 반드시 Action -> Dispatcher -> Store -> View의 순서로만 흐른다.

1. **Action**: 무엇을 할지 정의한 객체 (이벤트 발생)

2. **Dispatcher**: Action을 받아 모든 Store에 전달하는 중앙 허브.  Action을 받아 등록된 모든 Store에 전달함.

3. **Store**: 애플리케이션의 상태와 그 상태를 변경하는 로직을 가짐. 전달받은 Action에 따라 상태를 업데이트.

4. **View**: Store의 상태를 화면에 출력하고, 사용자가 화면에서 특정 액션을 취하면 다시 Action을 발생시킴.

**장점**
데이터 흐름이 단순(단방향)하여 예측 가능하며, 버그 디버깅이 훨씬 쉽다.

- 대표 라이브러리: Redux, Vuex.