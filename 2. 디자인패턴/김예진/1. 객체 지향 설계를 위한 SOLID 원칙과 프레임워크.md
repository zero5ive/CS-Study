# 디자인 패턴 (Design Pattern)

## 디자인 패턴
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 만들어놓은 하나의 규약. 라이브러리나 프레임워크의 기초 원리가 된다.

- **의의**: 문제 해결의 영감, 빠른 의사소통
  
### 디자인 패턴 종류
||설명|주요 패턴|
|--|--|--|
|**생성 패턴**|객체 생성 방식에 관여|**싱글톤, 팩토리**, 빌더, 추상 팩토리, 프로토타입|
|**구조 패턴**|객체/클래스를 조합해 더 큰 구조 형성|**프록시**, 어댑터, 브리지, 데코레이터, 퍼사드|
|**행동 패턴**|객체 간의 알고리즘 및 책임 할당|**이터레이터, 옵저버, 전략**, 템플릿 메서드|


# SOLID 원칙

**SOLID 원칙은 소프트웨어의 유지보수성과 확장성을 높이기 위한 객체지향 설계의 핵심 가이드라인이다.**

### 1. SRP (Single Responsibility Principle): 단일 책임 원칙

> 클래스는 단 하나의 책임만을 가져야 하며, 변경해야 하는 이유도 단 하나여야 한다.

하나의 클래스는 하나의 기능만 담당해야 한다. 클래스가 너무 많은 기능을 가지면 코드의 응집도가 낮아지고, 한 부분을 수정했을 때 예상치 못한 곳에서 버그가 발생할 확률(사이드 이펙트)이 높아진다.

- 이터레이터 패턴에서 '데이터 저장'과 '데이터 순회'를 분리하는 것이 SRP를 지키는 좋은 사례다.

- **장점**: 가독성이 좋아지고 유지보수가 쉬워진다.

### 2. OCP (Open-Closed Principle): 개방-폐쇄 원칙

> 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다.

기존의 코드를 변경하지 않으면서도 기능을 추가할 수 있도록 설계해야 한다는 원칙이다. 이를 가능하게 하는 핵심 도구는 **'추상화(Interface)'**다.

- 팩토리 패턴이 대표적이다. 
예를 들어, 새로운 커피 종류가 추가되어도 팩토리 클래스만 확장하면 될 뿐, 커피를 주문하는 메인 로직은 수정할 필요가 없다.

- **장점:** 기능 추가 시 기존 시스템의 안정성을 보장할 수 있다.

### 3. LSP (Liskov Substitution Principle): 리스코프 치환 원칙

> 상위 타입의 객체를 사용하는 곳에 하위 타입의 객체를 넣어도 프로그램의 동작이 변하지 않아야 한다.

자식 클래스는 언제나 부모 클래스의 역할을 완전히 대체할 수 있어야 한다. 단순히 컴파일에 성공하는 것을 넘어, 부모 클래스가 약속한 **행위의 의도(계약)**를 자식이 깨뜨려서는 안 된다.

- `새` 클래스를 상속받은 `타조` 클래스가 `날다` 메서드에서 예외를 던진다면, 이는 부모의 역할을 제대로 수행하지 못하는 것이므로 LSP 위반이다.

- **장점:** 다형성을 안전하게 보장하고 코드의 신뢰성을 높인다.

### 4. ISP (Interface Segregation Principle): 인터페이스 분리 원칙

> 클라이언트는 자신이 사용하지 않는 메서드에 의존하도록 강제되어서는 안 된다.

하나의 범용 인터페이스보다는 여러 개의 구체적인 인터페이스로 쪼개는 것이 낫다는 원칙이다. 비대한 인터페이스를 인터페이스를 사용하는 객체에 맞춰 작게 분리해야 한다.

- 인터페이스를 쪼개면 해당 기능을 사용하지 않는 클래스가 불필요한 메서드를 억지로 구현해야 하는 상황을 방지한다.

- **장점:** 시스템 간의 결합도를 낮추고 유연성을 확보한다.

### 5. DIP (Dependency Inversion Principle): 의존 관계 역전 원칙

> 추상화에 의존해야 하며, 구체화에 의존해서는 안 된다.

고수준 모듈(상위 전략)은 저수준 모듈(구체적인 구현)에 의존해서는 안 되며, 둘 다 추상화(인터페이스)에 의존해야 한다. 의존 관계를 맺을 때 변화하기 쉬운 구체적인 클래스보다 변화하기 어려운 인터페이스에 의존하라는 뜻이다.

- 의존성 주입(DI)의 이론적 근거다. Programmer가 MechanicalKeyboard라는 구체 클래스에 의존하지 않고 Keyboard라는 인터페이스에 의존하게 만드는 방식이다.

- **장점:** 모듈 간의 결합도가 낮아져 교체와 확장이 매우 용이해진다.



# 라이브러리와 프레임워크
라이브러리와 프레임워크 모두 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것이지만, **제어권**이 누구에게 있는지가 다름.
  
## 라이브러리
개발자가 주도권을 가지고 필요할 때마다 호출해서 사용하는 도구 모음. 규칙이 비교적 자유로움.
  
- **예시) Axios**: 네트워크 통신이 필요할 때 호출하며, 자유로운 규칙
  ```js
  // 개발자가 원할 때 가져와서 호출
  import axios from 'axios';

  axios.get('https://api.example.com/data')
    .then(response => console.log(response.data));
  ```

## 프레임워크
이미 정해진 규칙 안에 내 코드를 집어넣는 방식. 전체 흐름을 프레임워크가 제어하여, 프레임워크가 정해진 시점에 내 코드를 호출
  
폴더명, 파일명 등에 대한 규칙이 있으며 좀 더 엄격함

- **예시) Django (Python)**: 폴더명, 파일명 규칙이 매우 엄격
  - Django 프로젝트 기본 구조
  ```
    myproject/
  ├── manage.py
  ├── config/ (settings.py, urls.py) # 정해진 위치와 이름
  └── app/ (models.py, views.py) # 규칙에 따른 파일 생성
  ```
  - **예시 코드) Django View**: 개발자가 함수를 직접 실행하는 게 아니라, 장고가 URL 요청을 보고 이 함수를 호출
  ```python
  # views.py
  from django.http import HttpResponse

  # 함수만 만들어만 두고, 실행 주체는 프레임워크
  def index(request):
      return HttpResponse("Hello, Framework!")
  ```








**Q. 프레임워크와 라이브러리의 차이를 설명해주세요**

A. 라이브러리는 개발자가 주도권을 가지고 필요할 때 호출하는 도구로, 제어권은 개발자에게 있습니다. 프레임워크는, 프레임워크가 정의한 라이프사이클(규칙)에 따라 개발자가 작성한 코드를 프레임워크가 대신 호출합니다. (ex. 장고가 URL을 분석해 특정 뷰 함수를 실행)
