# 싱글톤 패턴 (Singleton Pattern)
하나의 클래스에 오직 **하나의 인스턴스**만 가지는 패턴. 데이터베이스 연결 모듈, I/O 바운드 작업 등 인스턴스 생성에 많은 코스트가 드는 많이 쓰임.

- **Lazy Holder 방식의 싱글톤 구현**
```java
  public class Singleton {
    // 1. private 생성자로 외부 인스턴스화 차단
    private Singleton() {}

    // 2. static 내부 클래스 (Holder) 이용
    // Singleton 클래스가 로드될 때는 Holder가 로드되지 않다가, 
    // getInstance() 호출 시점에 Holder가 로드되며 인스턴스를 생성함
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

- **장점**: 인스턴스 생성 비용 감소, 쉬운 데이터 공유
- **단점**: 클래스간 높은 의존성(결합도 증가), 단위 테스트와 TDD가 어려움
```java
  // JUnit 예시
  @Test
  public void test_A_상태변경() {
      Settings s = Settings.getInstance();
      s.setDarkMode(true); // 전역 상태 변경
  }

  @Test
  public void test_B_기본값확인() {
      Settings s = Settings.getInstance();
      // 테스트 A가 먼저 실행되었다면, 기본값인 false가 아니라 true가 나옴 -> 테스트 실패
      // 전역 상태를 공유하는 싱글톤의 특징으로 인해, 각 테스트 케이스가 독립적이지 않게 되어 이전 테스트의 결과가 다음 테스트에 영향을 줌
      assertFalse(s.isDarkMode()); 
  }
```

## 싱글톤 패턴을 구현하는 7가지 방법

**1. 단순한 메서드 호출**:
가장 기본적인 방식이나 멀티스레드 환경에서 안전하지 않음. 멀티 스레드 환경에서 동시에 접근 시 인스턴스가 2개 이상 생성될 수 있음.

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // 여러 스레드가 동시에 진입 시 2개 생성 가능
        }
        return instance;
    }
}
```

**2. synchronized 사용**:
스레드 안전을 보장하지만, 매번 lock이 발생하여 호출 시마다 성능 저하 발생.

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```


**3. 정적 멤버 (즉시 초기화)**:
클래스 로딩 시점에 인스턴스가 생성되어, 사용하지 않아도 메모리를 점유.

```java
public class Singleton {
    private final static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

**4. 정적 블록 (Static Block)**:
즉시 초기화와 유사하나 예외 처리가 가능

```java
public class Singleton {
    private static Singleton instance = null;
    static {
        try { instance = new Singleton(); } catch (Exception e) {}
    }
    private Singleton() {}
    public static Singleton getInstance() { return instance; }
}
```

**5. 정적 멤버와 Lazy Holder (중첩 클래스) - 추천 (가장 많이 쓰임)**: Singleton 클래스가 로딩되어도 내부의 Holder 클래스는 호출되기 전까지 로딩되지 않는 JVM의 특성을 이용한 방식

```java
public class Singleton {
    private Singleton() {} // private 생성자로 클래스 외부에서의 인스턴스 생성을 방지

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```
**작동 원리:**
1. 클래스 로딩: Singleton 클래스가 처음 로드될 때, Holder 클래스는 메모리에 올라가지 않음
2. 지연 초기화: 누군가 getInstance()를 호출하는 순간에만 Holder 클래스가 참조되며 로드
3. 원자성 보장: 클래스가 로드될 때 정적 변수(INSTANCE)가 초기화되는 과정은 JVM이 스레드 안전(Thread-safe)을 보장하므로, 별도의 synchronized 없이도 안전

**6. 이중 확인 잠금 (DCL, Double Checked Locking)**:
`volatile` 키워드를 통해 메인 메모리와 캐시 간 데이터 불일치를 해결

- **volatile의 특징**
  1. **가시성(Visibility) 보장**: CPU는 성능 향상을 위해 데이터를 각 스레드의 캐시 메모리에 복사해 사용하지만, volatile은 **메인 메모리(RAM)**를 직접 참조하게 강제. 
    이를 통해 한 스레드가 변경한 값을 다른 스레드가 즉시 확인할 수 있어 데이터 불일치 문제를 해결.
 
    2. **명령어 재정렬 방지**: 컴파일러나 CPU는 최적화를 위해 실행 순서를 바꿀 때가 있음. 
    volatile은 객체 생성 과정 **(메모리 할당 → 생성자 실행 → 주소 할당)**의 순서가 뒤바뀌지 않도록 보장하여, 다른 스레드가 **초기화되지 않은 가짜 객체**를 참조하는 치명적인 오류를 방지.


```java
public class Singleton {
    // 메인 메모리에 직접 읽고 써서, 객체 생성 순서가 뒤바뀌는 것을 방지 (안전성)
    private volatile static Singleton instance; 

    private Singleton() {}

    public static Singleton getInstance() {
        // 1차 확인: 이미 있으면 비싼 잠금(sync)을 하지 않고 바로 리턴 (성능)
        if (instance == null) { 
            synchronized (Singleton.class) {
                // 2차 확인: 스레드 A가 만드는 동안 기다리던 스레드 B가 들어왔을 때,
                // 중복으로 만드는 것을 방지 (안전성)
                if (instance == null) { 
                    instance = new Singleton(); 
                }
            }
        }
        return instance;
    }
}
```

**7. Enum 사용 - 추천 (Effective Java 방식)**:
enum의 인스턴스는 스레드세이프(thread safe)가 보장되어, 가장 간결하며 직렬화/리플렉션 공격에 안전함

```java
public enum SingletonEnum {
    INSTANCE;
    public void doSomething() {}
}
```

생성 패턴: 팩토리 패턴

# 팩토리 패턴 (Factory Pattern)
인터페이스, 추상클래스 같은 상위클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴.

객체 생성을 하위 클래스에 위임하므로, 상위 클래스는 어떤 구체적인 객체가 생성하는지 몰라도 된다.

**장점**

- **느슨한 결합**: 객체 생성 로직을 분리하여 상위 클래스는 구체적인 클래스에 의존하지 않음. 결합도를 낮추고 유연성을 가짐.

- [**개방-폐쇄 원칙(OCP)**](https://velog.io/@yejiiiin/SOLID-%EC%84%A4%EA%B3%84-%EC%9B%90%EC%B9%99-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99#2-ocp-open-closed-principle-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99): 새로운 타입(예: 신메뉴 커피)이 추가되어도 기존의 주문 로직(CoffeeFactory를 사용하는 쪽)은 수정할 필요가 없음.

```java
// 상위 클래스: 뼈대 제공
abstract class Coffee { public abstract int getPrice(); }

// 하위 클래스: 구체적 구현
class Latte extends Coffee { @Override public int getPrice() { return 4500; } }
class Espresso extends Coffee { @Override public int getPrice() { return 4000; } }

// 팩토리 클래스: 객체 생성 전담 (캡슐화)
class CoffeeFactory {
    public static Coffee createCoffee(String type) {
        if ("Latte".equalsIgnoreCase(type)) return new Latte();
        else if ("Espresso".equalsIgnoreCase(type)) return new Espresso();
        return null; // 실무에서는 예외 처리를 권장
    }
}
```


# 프록시 패턴 (Proxy Pattern)
대상 객체에 접근하기 전, 그 접근을 가로채서 보안, 캐싱, 데이터 수정 등을 수행하는 대리인(Proxy)을 두는 패턴.

- 실제 객체의 기능에 제어 흐름을 추가한다.

- 예시: 프록시 서버(Nginx, Cloudflare), Spring AOP(트랜잭션 처리 등).

## @Transactional과 프록시 패턴의 동작 원리
### 1. 프록시 도입 전

```java
public void saveUser() {
    EntityTransaction tx = em.getTransaction();
    try {
        tx.begin(); // 1. 트랜잭션 시작 (부가 기능)
        
        // --- 비즈니스 로직 (핵심 기능) ---
        userRepository.save(user); 
        // ------------------------------
        
        tx.commit(); // 2. 정상 실행 시 커밋 (부가 기능)
    } catch (Exception e) {
        tx.rollback(); // 3. 에러 발생 시 롤백 (부가 기능)
    }
}
```
비즈니스 로직보다 트랜잭션을 관리하는 코드가 더 길어진다는 문제가 생기는데, 이로 인해 SRP(단일 책임 원칙)을 위반하게 된다.

### 2. 프록시 도입
Spring은 `@Transactional`이 붙은 클래스나 메서드를 발견하면, 실제 객체 대신 **가짜 대리인(프록시 객체)**를 생성하여 스프링 빈으로 등록한다.


**동작 순서**

1. **클라이언트 호출**: 클라이언트(예: 컨트롤러)가 서비스의 saveUser() 메서드를 호출한다. 이때 호출되는 것은 실제 서비스 객체가 아니라 프록시 객체다.

2. **프록시의 가로채기**: 프록시 객체는 실제 로직을 실행하기 전, 먼저 트랜잭션을 시작한다. (tx.begin())

3. **실제 객체 호출**: 트랜잭션 환경이 세팅되면, 프록시가 실제 서비스 객체의 로직을 호출한다.

4. **후처리**:
    - 로직이 성공적으로 끝나면 프록시가 트랜잭션을 커밋한다.
    - 로직 실행 중 예외가 발생하면 프록시가 트랜잭션을 롤백한다.

- 프록시는 대상 객체에 접근하기 전, 대리인이 그 접근을 가로채어 제어 흐름을 추가한다. 여기서 대상 객체는 순수 비즈니스 로직을 가진 클래스고, 대리인인 프록시는 트랜잭션 처리 로직이 추가된 가짜 서비스 클래스다.

- 실제 서비스 객체는 DB 트랜잭션이 어떻게 시작되고 끝나는지 알 필요가 없다. 자기 할 일(데이터 저장)만 하면 되고, 나머지 다른 일은 프록시가 다 가로채서 처리한다.

## 프록시 패턴을 이용하면 발생할 수 있는 문제

- **내부 호출(Self-Invocation) 문제**:
같은 클래스 내에서 @Transactional이 없는 메서드가 @Transactional이 있는 메서드를 호출하면 프록시가 작동하지 않는다. 
프록시를 거치지 않고 실제 객체(this)가 직접 호출하기 때문에 가로챌 기회가 없기 때문이다.

  - 서비스 클래스를 분리하거나, AopContext를 사용하거나, 자기 자신을 주입받는 등의 방법으로 해결한다.

- **Public 메서드에만 적용**: 
프록시가 밖에서 가로채려면 접근이 가능해야 하므로, 보통 public 메서드에만 @Transactional이 적용된다.


# 전략 패턴 (Strategy Pattern)

알고리즘군을 정의하고 각각을 캡슐화하여, 실행 중에 알고리즘을 선택해 교체할 수 있게 하는 패턴. 

- 상속보다는 합성(Composition, `has-a 관계`)을 활용하여 컨텍스트의 코드 변경 없이 동작을 바꾼다.

- 예시: Passport.js에서 로그인 전략(Google, Facebook, Local)만 바꿔 끼우는 구조

# 옵저버 패턴 (Observer Pattern)
어떤 객체의 상태가 변하면 그 객체에 의존하는 다른 객체들에게 연락이 가고 자동으로 내용이 갱신되는 방식.

주체가 어떤 객체(subject)의 상태 변화를 관찰하다가, 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려준다.

- 주체(Subject)와 옵저버(Observer) 간의 느슨한 결합을 유지한다.

- 예시: 트위터 팔로우 시스템, 발행-구독(Pub-Sub) 모델, MVC에서 모델의 변화를 뷰에 알릴 때.


# 이터레이터 패턴 (Iterator Pattern)
배열, 리스트, 맵 등 다양한 컬렉션(컨테이너)의 내부 구조를 노출하지 않고 요소들에 순차적으로 접근할 수 있게 하는 패턴

**장점**

- **인터페이스 통일**: 자료구조가 바뀌어도(List -> Set) 순회하는 코드는 동일하게 유지할 수 있음.

- [**단일 책임 원칙(SRP)**](https://velog.io/@yejiiiin/SOLID-%EC%84%A4%EA%B3%84-%EC%9B%90%EC%B9%99-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99#1-srp-single-responsibility-principle-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99): 자료구조의 '데이터 저장' 책임과 '순회' 책임을 분리할 수 있음.


```java
// Java의 내장 Iterator 활용 예시
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Iterator<String> it = names.iterator(); // 내부 구조에 상관없이 동일한 인터페이스 획득

while (it.hasNext()) { // 다음 요소가 있는지 확인
    System.out.println(it.next()); // 다음 요소를 반환
}
```


---
**Q. 싱글톤은 안티 패턴이다"라는 의견이 있습니다. 싱글톤 패턴이 객체 지향 설계와 테스트(TDD) 측면에서 어떤 단점을 가지나요?**

A. 

[객체 지향 설계 측면] 

싱글톤은 Static 메서드를 통해 어디서든 접근 가능하므로 클래스 간의 결합도를 높입니다. 또한, 추상화가 아닌 구체 클래스에 직접 의존하기 때문에 다형성을 활용하기 어렵습니다. 이로 인해 새로운 기능을 추가할 때 기존 코드를 수정하게 만들어 개폐 원칙(OCP)을 위반하고 유연성을 떨어뜨립니다.

[테스트 측면] 

결합도가 높기 때문에 테스트 시 가짜 객체(Mock)로 교체하기가 매우 어렵습니다. 또한, 싱글톤 인스턴스가 전역 상태를 공유하므로, 각 단위 테스트가 독립적으로 수행되지 못하고 테스트 순서에 따라 결과가 달라지게 됩니다.

  - **OCP(개폐 원칙, Open-Closed Principle)**: 소프트웨어 요소는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다"는 원칙. <br>싱글톤은 보통 생성자가 `private`이고 인스턴스를 정적으로 고정해서 관리하므로, 상속받아 오버라이딩하거나 인터페이스를 구현해서 갈아끼울 수 없음. 기능을 바꾸려면 기존 클래스의 코드를 직접 수정해야 함 -> 수정에 닫혀있지 않음
