# 클래스와 객체와 인스턴스의 차이는 무엇인가? ★★★
 

# 클래스
클래스(class)란 객체(object)를 만들어 내기 위한 틀이며 만들어 낼 객체의 속성과 메서드의 집합을 담아놓은 것

 

 

# 객체
객체란 클래스로부터 만들어지는 실체, 클래스로 선언된 변수를 객체라 한다. 

- 클래스로 선언된 변수는 객체를 참조한다
- 객체란 클래스로부터 생성되어 힙 메모리에 존재하는 실체이다.
 

 

# 인스턴스
인스턴스(instance)란 객체가 메모리에 할당이 된 상태이며 런타임에 구동되는 객체를 말한다. 객체와 같은 의미로 쓰이기도 한다.

- 인스턴스란 특정 클래스로부터 생성된 객체를, 그 ‘출신(클래스)’을 강조해서 부르는 말이다.

  <img width="956" height="260" alt="image" src="https://github.com/user-attachments/assets/a35f6d93-840d-420d-88d9-a38e666ba93e" />

 

 


 

 

- 객체와 인스턴스는 자바에서 동일한 메모리 실체를 의미하며, 인스턴스는 특정 클래스로부터 생성되었음을 강조하는 표현이다. (붕어빵 틀로 찍어냈다는 것을 강조 함)
- 객체와 인스턴스는 다른 것이 아니라, 같은 것을 부르는 관점의 차이다.
- 인스턴스는 특정 클래스로부터 생성된 객체를 의미하며, 자바에서는 객체와 인스턴스를 동일한 메모리 실체로 본다.
 

```
public class Person {
// 멤버변수(속성)
String name;
int IQ;
int str;
// constructor
public Person(String name, int IQ, int str){
this.name = name;
this.IQ = IQ;
this.str = str;
}
public Person(){
this.name = "alanwalker";
this.IQ = 100;
this.str = 100;
}
// 메서드
public void levelup(){
this.IQ = this.IQ + 1;
this.str = this.str + 1;
System.out.println(this.name + "의 지능과 힘이 증가했습니다!
" + this.IQ + " / " + this.str);
}
public static void main(String[] args) {
Person a = new Person(); // 객체 >> 인스턴스
a.levelup();
Person b; // 객체
b = new Person("홍철"
b.levelup();
, 1, 1000); // 인스턴스
}
}
```

 

 

 

 

# staic 키워드는 왜 사용하며 단점은 무엇인가? ★
 

# static
static키워드는 클래스의 인스턴스가 아닌 클래스에 속하며 클래스의 변수, 메서드 등을 공유하는데 사용된다. 이를 통해 해당 클래스로 만들어지는 객체 사이에서 중복되는 메서드, 속성을 효율적으로 정의할 때 쓰인다.(강의 자료)

 

Java에서 static은 클래스에 소속되는 키워드이다. 인스턴스와 달리 new로 객체를 생성하지 않아도 사용할 수 있고, 클래스가 JVM에 로딩될 때 Method Area에 한 번만 생성된다. 그래서 여러 인스턴스가 같은 값을 공유하게 된다.

 

 

### static을 사용하는 이유

객체 상태와 무관한 공통 데이터나 기능을 클래스 단위로 관리하기 위해 사용한다.

(클래스 단위로 관리한다는 것은 특정 객체에 종속되지 않고 클래스 자체에 하나만 존재하며 모든 인스턴스가 공유하도록 설계한다는 의미이다.)

 

- static은 객체가 아니다.
- Java에서 객체는 new 시 Heap에 생성되지만, static 멤버는 클래스가 처음 로딩될 때 Method Area(클래스 단위 정보가 저장되는 JVM 영역)에 생성되어 모든 인스턴스가 공유
- static은 클래스당 하나만 존재하고, 객체(인스턴스)는 new할 때마다 새로 생성된다.

  <img width="1646" height="618" alt="image" src="https://github.com/user-attachments/assets/2b4e0f49-fb4a-4aac-8103-4828e14607bb" />

 


 

 

# static의 단점
static은 클래스 로딩 시 생성돼 수명이 길어서 잘못 사용하면 메모리를 오래 점유할 수 있다. 다만 더 중요한 단점은 전역 상태가 되면서 객체지향 설계를 약화시키고, 테스트와 멀티스레드 환경에서 문제를 만들 수 있다는 점이다.

 

### 객체 지향 설계를 약화시킨다는 것의 의미

- 객체를 여러개 만들어도 static변수는 그 클래스에만 귀속 되어서 어떤 객체의 상태인 지 알 수 없다.
- 다형성과 확장성이 깨진다.(static 메서드는 오버라이딩 불가능해서 인터페이스 구현도 의미 없다.)
 

 

 

 

# 오버로딩과 오버라이딩은 무엇인가? ★★★
 
 

# 오버로딩(Overloading)
오버로딩은 이름이 같아도 매개변수 개수, 타입, 순서를 다르게 해서 같은 이름으로도 여러 개의 함수를 정의할 수 있는 것을 말한다. 이는 프로그램의 유언성을 높이고 결과적으로 코드를 깔끔하게 하는 효과가 있으며 같은 클래스내에서 사용한다.

 
```
class Calculator {

    int add(int a, int b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }

    double add(double a, double b) {
        return a + b;
    }
}
```

 

# 오버라이딩(Overriding)
상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하는 것을 말한다. 상속 관계 클래스에서 사용되며 static, final로 선언한 메서드는 오버라이딩이 불가능 하다.

 
```
class Animal {
    void sound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍");
    }
}
```
```
Animal a = new Dog();
a.sound(); // 멍멍
```

<img width="1646" height="640" alt="image" src="https://github.com/user-attachments/assets/8d9cdb06-3185-4e91-a547-23dfb903332c" />



- 오버로딩은 같은 기능을 다양한 매개변수 형태로 제공해 사용성과 가독성을 높이기 위해 사용한다.
- 오버라이딩은 부모 타입으로 메서드를 호출하더라도 실제로 생성된 자식 객체의 메서드가 실행되게 하는다형성의 핵심 기능이다.
 

 

 

 

 

# 추상화란 무엇인가? ★★★
 

# 추상화
프로그래밍에서의 추상화는 복잡한 데이터, 구조, 시스템등으로부터 핵심만을 가려내 덜 자세하게 만드는 것 또는 세부사항, 절차 등을 감추고 인터페이스 등을 만드는 것으로 복잡도는 낮추는 방법을 말한다.

 

- 추상화란 객체의 공통된 특징과 동작만 뽑아내어 ‘무엇을 할 수 있는지’만 드러내고 구현은 숨기는 설계 개념이다.

  <img width="1664" height="1116" alt="image" src="https://github.com/user-attachments/assets/58b01711-f812-4806-a6c0-ff51d5048ca4" />

 


 

인터페이스는 메서드 구현코드는 만들지 않고 규칙만 세워 둠

```
interface Animal {
    void sound(); // 규칙
}
```

메서드 구현은 하위 클래스가 담당

```
class Dog implements Animal {

    @Override
    public void sound() {
        System.out.println("멍멍"); // 일반 메서드 구현
    }

    void run() {                  // 새로운 일반 메서드
        System.out.println("달린다");
    }
}
```

 

### 추상클래스와 인터페이스의 차이

추상 클래스는 공통 기능을 구현해서 제공하면서 필요한 부분만 구현을 강제하고, 인터페이스는 구현 없이 역할과 규칙만 정의해 모든 구현을 강제한다.

 

 

# 데이터 추상화
어떠한 데이터들의 공통점을 모으고 차이점은 버린다.

예를 들어 고양이, 강아지, 원숭이 등의 객체들의 공통적인 특징을 묶어 동물이라는 캬테고리화 시킨다.

```
abstract class Animal {
public abstract void animalSound();
public void sleep() {
System.out.println("zzz");
}
}
class Pig extends Animal {
public void animalSound() {
System.out.println("꿀꿀꿀~");
}
}
class Dog extends Animal {
public void animalSound() {
System.out.println("왈왈~");
}
}
public class Main {
public static void main(String[] args) {
Pig a = new Pig();
a.animalSound();
a.sleep();
Dog b = new Dog();
b.animalSound();
b.sleep();
}
}
```

 

# 프로세스추상화
어떠한 내부 프로세스를 숨기는 것을 말한다.

예를들어 데이터베이스가 어떻게 데이터를 저장하는지는 모르지만 단순하게 Insert, upsert등의 쿼리로 데이터를 저장할 수 있다.

 

 

 

 

# 컴파일러 언어와 인터프리터 언어의 차이가 무엇인가? ★
 

- 컴파일러와 인터프리터는 프로그래밍 언어로 작성된 코드를 컴퓨터가 이해할 수 있는 기계어로 변환하는 과정에 관여하는 프로그램이다.
(기계어란 컴퓨터가 직접 이해하고 실행할 수 있는 0과 1로 이루어진 가장 낮은 수준의 언어이다.)

<img width="1416" height="552" alt="image" src="https://github.com/user-attachments/assets/e1349d9e-2f31-4af4-b81a-edc2d7cc4072" />


 


 

# 컴파일러
### 컴파일러란 사람이 작성한 고급 언어를 실행 전에 한 번에 기계어로 변환하는 프로그램이다.

- 전체 변환 : 소스 코드의 전체를 읽어 한 번에 기계어로 변환한다. 변환 과정을 거친 후 생성된 기계어 코드를 실행한다.
- 속도 : 컴파일 과정 자체는 시간이 걸리지만, 변환된 코드는 직접 실행되므로 실행되는 시간은 빠르다.
- 사용 예 : C, C++, Go, Rust 등의 언어가 컴파일러를 사용한다.
- 코드를 수정했을 때 컴파일 과정이 필요하다.
(컴파일 과정이란 고수준의 소스코드를 전처리, 컴파일러, 어셈블러, 링커의 과정을 거쳐 저수준언어로 만들고 실행할 수 있는 프로그램을 만드는 과정이다.)

 

 

# 인터프리터
### 인터프리터란 사람이 작성한 고급 언어를 프로그램을 실행하면서 한 줄씩 읽고 즉시 해석·실행하는 프로그램이다.

- 한 줄씩 변환 : 소스 코드를 한 줄씩 읽어가며 바로 기계어로 변환하고 실행한다. 
- 속도 : 컴파일 단계가 없으므로 초기 시작은 빠르지만, 전체 코드 실행 시간은 컴파일러를 사용할 때 보다 느릴 수 있다. 코드를 실행할 때 마다 변환 과정을 거치기 때문
- Python이 대표적으로 인터프리터 방식을 사용한다.
- 코드를 수정했을 때 컴파을 과정이 필요하지 않다.
 

 

### 컴파일러와 인터프리터 모두 고급 언어를 실행 가능하게 하지만, 컴파일러는 실행 전에 전체를 변환하고, 인터프리터는 실행하면서 한 줄씩 해석한다.

컴파일러는 코드를 실행 가능한 형태로 변환(기계어로)만 하고, 인터프리터는 코드를 해석하면서 실행한다.

 

 

### 자바는 JVM에서 인터프리터와 JIT 컴파일러를 함께 사용해 실행된다.

# JIT 컴파일러
JIT 컴파일러는 프로그램 실행 중에 자주 실행되는 코드를 기계어로 변환해 성능을 향상시키는 컴파일러다.

 

- JVM은 처음에 모든 코드를 바로 기계어로 바꾸지 않는다
- 자주 실행되는 코드(HotSpot) 만 골라서
- JIT 컴파일러가 기계어로 변환
자주 실행되지 않는 코드는 인터프리터가 해석 (한줄 씩 앍어서)

<img width="1510" height="1154" alt="image" src="https://github.com/user-attachments/assets/6c774428-bad2-45f0-8ae6-95a9554d2393" />



 

 
