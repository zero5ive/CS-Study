# 컨테이너 & 도커 & 쿠버네티스
## 컨테이너
애플리케이션과 실행에 필요한 모든 환경(코드, 라이브러리 등)을 하나로 패키징한 소프트웨어 단위
![](https://velog.velcdn.com/images/yejiiiin/post/73dc0abf-8461-48b2-b2ac-7467e1f055e3/image.png)

- 핵심 원리 (격리 기술):
  - Namespace: 각 프로세스가 독립된 공간(네트워크, 사용자, 파일시스템 등)을 보게 함
  - Cgroups (Control Groups): 각 컨테이너가 사용할 CPU, 메모리 양을 제한

- 장점
OS 커널을 공유하므로 VM보다 월등히 가볍고 부팅이 빠름.

- 단점
Host OS 커널을 공유하므로, 커널 레벨의 보안 취약점에 노출될 경우 격리벽이 무너질 수 있음 (VM보다 보안 수준 낮음)



## 도커 (Docker)
컨테이너 기반의 오픈소스 가상화 플랫폼으로, 컨테이너 배포에 필요한 거의 모든 기능을 제공
- IaaS의 장점인 유연성, 이식성, PaaS의 장점인 운영비 효율을 모두 장점으로 가짐

### 도커의 과정
![](https://velog.velcdn.com/images/yejiiiin/post/b236807a-3e6c-4bec-b538-723766a98428/image.png)

1. 도커 파일
   - 패키지 설치, 환경 변수, 실행 명령 등을 기록한 텍스트 기반 스크립트
   - 이를 빌드해 도커 이미지로 변경

2. 도커 이미지
   - 한 번 빌드된 이미지는 수정되지 않으며, 실행 중 상태가 변해도 이미지는 원본을 유지함
   - 하나의 이미지에서 여러 개의 컨테이너를 생성할 수 있음
   - 여러 개의 읽기 전용(Read-only) 레이어가 쌓인 형태로, 바뀐 부분(Layer)만 새로 만들기 때문에 용량과 시간이 크게 절약됨

3. 도커 컨테이너
   - 이미지를 실행한 상태
   - 이미지 레이어 위에 쓰기 가능한(Writable) 레이어를 한 층 올려서 데이터를 저장하고 수정
   - 컨테이너가 실행시키면 도커 이미지에 설정된 프로그램, 데이터 등이 실제 컴퓨팅 자원과 연결됨
   
   
## 쿠버네티스 (Kubernetes)
**컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화해 주는 오픈소스 컨테이너 오케스트레이션 플랫폼**

### 쿠버네티스 핵심 객체
|단위|설명|비고|
|--|--|--|
|Pod (파드)|쿠버네티스에서 생성하고 관리할 수 있는 최소 배포 단위. 하나 이상의 컨테이너를 포함함.|도커 컨테이너를 감싼 주머니 같은 개념|
|Node (노드)|쿠버네티스 배포판이 실행되는 물리적/가상 머신. (Worker Node / Master Node)|파드들이 실행되는 실제 서버|
|Cluster (클러스터)|여러 노드들을 하나로 묶어 관리하는 전체 시스템|쿠버네티스의 전체 인프라 단위|

### 쿠버네티스 주요 기능
- **셀프 힐링 (Self-healing)**
컨테이너가 죽으면 쿠버네티스가 이를 감지하고 자동으로 다시 시작하거나 교체
사용자는 서비스가 중단되었는지조차 모르게 관리됨

- **오토 스케일링 (Auto-scaling)**
트래픽이 급증하면 컨테이너 개수를 자동으로 늘리고(Scale-out), 한가해지면 다시 줄여서 자원을 효율적으로 사용

- **로드 밸런싱 및 서비스 디스커버리**
수많은 파드에 트래픽을 골고루 분산시켜 주고, 파드의 IP가 바뀌어도 이름을 통해 서로 찾을 수 있게 함

- **자동화된 롤아웃과 롤백**
애플리케이션 업데이트 시 조금씩 배포하여 문제가 생기면 즉시 이전 버전으로 롤백

### 도커 vs 컨테이너
||도커 (Docker)|쿠버네티스 (Kubernetes)|
|--|--|--|
|목적|컨테이너의 생성과 실행|컨테이너들의 통합 관리 및 운영|
|범위|단일 컨테이너 혹은 단일 호스트 위주|수많은 서버(노드)에 걸친 클러스터 위주|
|핵심 파일|Dockerfile|YAML (설정 파일)|

# CI/CD

**소스 코드 변경부터 실제 서비스 반영까지의 과정을 자동화하여, 배포 주기를 단축하고 품질을 높이는 전략**

## CI (Continuous Integration: 지속적 통합)
- 목적
  코드의 품질 관리 및 통합 충돌 조기 발견 (Fail Fast)
  
- 과정
  코드 푸시 → 빌드 → 자동화 테스트 → 머지
  
## CD (Continuous Delivery & Deployment: 지속적 제공 및 배포)
- **Continuous Delivery (지속적 제공)**
  빌드된 결과물이 운영 환경에 배포될 준비는 끝났으나, 최종 배포는 관리자의 승인을 거쳐 수동으로 이루어짐
- **Continuous Deployment (지속적 배포)**
  테스트를 통과한 코드가 사용자에게 즉시 자동 배포

## CI/CD 파이프라인
코드 구축부터 배포까지 일련의 과정들
코드 배포 과정을 체계적으로 만들고, 파이프라인 자체 내에 테스트가 있어 테스트가 없으면 코드가 병합되는 것을 막을 수 있음

![](https://velog.velcdn.com/images/yejiiiin/post/c79a15c3-6b24-4530-9dce-9b0c12af1899/image.png)

- continuous integration: 코드를 빌드하고 테스트하고 병합
- continuous delivery: 해당 레퍼지토리에 릴리스
- continuous deployment: 프로덕션, 실제 서비스에 배포

### 1. 코드 빌드 (Build)
소스 코드를 실행 가능한 소프트웨어 패키지로 변환
- Frontend
Webpack, Vite 등을 이용한 정적 자산 번들링
- Backend
Java(Gradle/Maven), Go 등의 컴파일 작업
- **Docker화** [도커란?](https://velog.io/@yejiiiin/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0-%EC%98%A4%ED%94%84%ED%94%84%EB%A0%88%EB%AF%B8%EC%8A%A4%EC%99%80-%EC%98%A8%ED%94%84%EB%A0%88%EB%AF%B8%EC%8A%A4-IaaS-PaaS-SaaS#%EB%8F%84%EC%BB%A4-docker)
소스 코드를 컴파일하는 것에 그치지 않고, Dockerfile을 빌드하여 도커 이미지로 패키징하는 과정
  이미지 안에 런타임 환경이 포함되어 있어, 개발/테스트/운영 서버 간의 **환경 불일치 문제**를 해결함

### 2. 자동화 테스트 (Test)
- 단위 테스트 (Unit Test)
  함수, 컴포넌트 단위. 가장 하단. 빠르고 비용이 저렴함
- 통합 테스트 (Integration Test)
  단위 테스트 이후, 여러 모듈 간의 협력을 검증 (DB 연동 등)
- 엔드 투 엔드 테스트 (End-to-End)
  상단. 사용자 시나리오를 기반으로 전체 흐름 검증 (가장 느리고 비용이 높음)

### 3. 배포 (Deploy)
사용자를 위한 서비스 배포는 물론, 내부적으로 QA엔지니어나 관리자 페이지를 위한 배포, 데이터 웨어하우스로부터 데이터를 가공하여 백엔드 개발자를 위한 배포 등을 포함

- Blue-Green
  똑같은 서버 환경을 두 개(신/구) 만들어 한꺼번에 교체
- Canary
  일부 사용자에게만 새 버전을 노출해보고 점진적으로 확대
- Rolling
  서버를 하나씩 순차적으로 업데이트

#### 배포 툴
||주요 도구|특징|
|--|--|--|
|CI/CD 엔진|Jenkins|오픈소스, 강력한 커스터마이징, 직접 서버 운영 필요|
||GitHub Actions|GitHub 완전 통합, 설정이 매우 간편(YAML)|
||GitLab CI/CD|GitLab 자체 내장, 협업 및 DevOps 통합에 유리|
|자동화 테스트|Jest, Mocha, Cypress|프론트엔드/백엔드 테스트 프레임워크|
|인프라 관리|Docker, Kubernetes|애플리케이션의 일관성 있는 배포를 보장|
