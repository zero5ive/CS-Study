# 디자인 패턴 (Design Pattern)

## 디자인 패턴
### 디자인 패턴 소개
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 만들어놓은 하나의 규약. 라이브러리나 프레임워크의 기초 원리가 된다.

- **의의**: 문제 해결의 영감, 빠른 의사소통
  
### 디자인 패턴 종류
||설명|주요 패턴|
|--|--|--|
|**생성 패턴**|객체 생성 방식에 관여|**싱글톤, 팩토리**, 빌더, 추상 팩토리, 프로토타입|
|**구조 패턴**|객체/클래스를 조합해 더 큰 구조 형성|**프록시**, 어댑터, 브리지, 데코레이터, 퍼사드|
|**행동 패턴**|객체 간의 알고리즘 및 책임 할당|**이터레이터, 옵저버, 전략**, 템플릿 메서드|

## 싱글톤 패턴 (Singleton Pattern)
하나의 클래스에 오직 **하나의 인스턴스**만 가지는 패턴. 데이터베이스 연결 모듈, I/O 바운드 작업 등 인스턴스 생성에 많은 코스트가 드는 많이 쓰임.

- **Lazy Holder 방식의 싱글톤 구현**
```java
  public class Singleton {
    // 1. private 생성자로 외부 인스턴스화 차단
    private Singleton() {}

    // 2. static 내부 클래스 (Holder) 이용
    // Singleton 클래스가 로드될 때는 Holder가 로드되지 않다가, 
    // getInstance() 호출 시점에 Holder가 로드되며 인스턴스를 생성함
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

- **장점**: 인스턴스 생성 비용 감소, 쉬운 데이터 공유
- **단점**: 클래스간 높은 의존성(결합도 증가), 단위 테스트와 TDD가 어려움
```java
  // JUnit 예시
  @Test
  public void test_A_상태변경() {
      Settings s = Settings.getInstance();
      s.setDarkMode(true); // 전역 상태 변경
  }

  @Test
  public void test_B_기본값확인() {
      Settings s = Settings.getInstance();
      // 테스트 A가 먼저 실행되었다면, 기본값인 false가 아니라 true가 나옴 -> 테스트 실패
      // 전역 상태를 공유하는 싱글톤의 특징으로 인해, 각 테스트 케이스가 독립적이지 않게 되어 이전 테스트의 결과가 다음 테스트에 영향을 줌
      assertFalse(s.isDarkMode()); 
  }
```

### 싱글톤 패턴을 구현하는 7가지 방법

**1. 단순한 메서드 호출**:
가장 기본적인 방식이나 멀티스레드 환경에서 안전하지 않음. 멀티 스레드 환경에서 동시에 접근 시 인스턴스가 2개 이상 생성될 수 있음.

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // 여러 스레드가 동시에 진입 시 2개 생성 가능
        }
        return instance;
    }
}
```

**2. synchronized 사용**:
스레드 안전을 보장하지만, 매번 lock이 발생하여 호출 시마다 성능 저하 발생.

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```


**3. 정적 멤버 (즉시 초기화)**:
클래스 로딩 시점에 인스턴스가 생성되어, 사용하지 않아도 메모리를 점유.

```java
public class Singleton {
    private final static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

**4. 정적 블록 (Static Block)**:
즉시 초기화와 유사하나 예외 처리가 가능

```java
public class Singleton {
    private static Singleton instance = null;
    static {
        try { instance = new Singleton(); } catch (Exception e) {}
    }
    private Singleton() {}
    public static Singleton getInstance() { return instance; }
}
```

**5. 정적 멤버와 Lazy Holder (중첩 클래스) - 추천 (가장 많이 쓰임)**: Singleton 클래스가 로딩되어도 내부의 Holder 클래스는 호출되기 전까지 로딩되지 않는 JVM의 특성을 이용한 방식

```java
public class Singleton {
    private Singleton() {} // private 생성자로 클래스 외부에서의 인스턴스 생성을 방지

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```
**작동 원리:**
1. 클래스 로딩: Singleton 클래스가 처음 로드될 때, Holder 클래스는 메모리에 올라가지 않음
2. 지연 초기화: 누군가 getInstance()를 호출하는 순간에만 Holder 클래스가 참조되며 로드
3. 원자성 보장: 클래스가 로드될 때 정적 변수(INSTANCE)가 초기화되는 과정은 JVM이 스레드 안전(Thread-safe)을 보장하므로, 별도의 synchronized 없이도 안전

**6. 이중 확인 잠금 (DCL, Double Checked Locking)**:
`volatile` 키워드를 통해 메인 메모리와 캐시 간 데이터 불일치를 해결

- **volatile의 특징**
  1. **가시성(Visibility) 보장**: CPU는 성능 향상을 위해 데이터를 각 스레드의 캐시 메모리에 복사해 사용하지만, volatile은 **메인 메모리(RAM)**를 직접 참조하게 강제. 
    이를 통해 한 스레드가 변경한 값을 다른 스레드가 즉시 확인할 수 있어 데이터 불일치 문제를 해결.
 
    2. **명령어 재정렬 방지**: 컴파일러나 CPU는 최적화를 위해 실행 순서를 바꿀 때가 있음. 
    volatile은 객체 생성 과정 **(메모리 할당 → 생성자 실행 → 주소 할당)**의 순서가 뒤바뀌지 않도록 보장하여, 다른 스레드가 **초기화되지 않은 가짜 객체**를 참조하는 치명적인 오류를 방지.


```java
public class Singleton {
    // 메인 메모리에 직접 읽고 써서, 객체 생성 순서가 뒤바뀌는 것을 방지 (안전성)
    private volatile static Singleton instance; 

    private Singleton() {}

    public static Singleton getInstance() {
        // 1차 확인: 이미 있으면 비싼 잠금(sync)을 하지 않고 바로 리턴 (성능)
        if (instance == null) { 
            synchronized (Singleton.class) {
                // 2차 확인: 스레드 A가 만드는 동안 기다리던 스레드 B가 들어왔을 때,
                // 중복으로 만드는 것을 방지 (안전성)
                if (instance == null) { 
                    instance = new Singleton(); 
                }
            }
        }
        return instance;
    }
}
```

**7. Enum 사용 - 추천 (Effective Java 방식)**:
enum의 인스턴스는 스레드세이프(thread safe)가 보장되어, 가장 간결하며 직렬화/리플렉션 공격에 안전함

```java
public enum SingletonEnum {
    INSTANCE;
    public void doSomething() {}
}
```


# 라이브러리와 프레임워크
라이브러리와 프레임워크 모두 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것이지만, **제어권**이 누구에게 있는지가 다름
  
## 라이브러리
개발자가 주도권을 가지고 필요할 때마다 호출해서 사용하는 도구 모음. 규칙이 비교적 자유로움.
  
- **예시) Axios**: 네트워크 통신이 필요할 때 호출하며, 자유로운 규칙
  ```js
  // 개발자가 원할 때 가져와서 호출
  import axios from 'axios';

  axios.get('https://api.example.com/data')
    .then(response => console.log(response.data));
  ```

## 프레임워크
이미 정해진 규칙 안에 내 코드를 집어넣는 방식. 전체 흐름을 프레임워크가 제어하여, 프레임워크가 정해진 시점에 내 코드를 호출
  
폴더명, 파일명 등에 대한 규칙이 있으며 좀 더 엄격함

- **예시) Django (Python)**: 폴더명, 파일명 규칙이 매우 엄격
  - Django 프로젝트 기본 구조
  ```
    myproject/
  ├── manage.py
  ├── config/ (settings.py, urls.py) # 정해진 위치와 이름
  └── app/ (models.py, views.py) # 규칙에 따른 파일 생성
  ```
  - **예시 코드) Django View**: 개발자가 함수를 직접 실행하는 게 아니라, 장고가 URL 요청을 보고 이 함수를 호출
  ```python
  # views.py
  from django.http import HttpResponse

  # 함수만 만들어만 두고, 실행 주체는 프레임워크
  def index(request):
      return HttpResponse("Hello, Framework!")
  ```


---
**Q. 싱글톤은 안티 패턴이다"라는 의견이 있습니다. 싱글톤 패턴이 객체 지향 설계와 테스트(TDD) 측면에서 어떤 단점을 가지나요?**

A. 

[객체 지향 설계 측면] 

싱글톤은 Static 메서드를 통해 어디서든 접근 가능하므로 클래스 간의 결합도를 높입니다. 또한, 추상화가 아닌 구체 클래스에 직접 의존하기 때문에 다형성을 활용하기 어렵습니다. 이로 인해 새로운 기능을 추가할 때 기존 코드를 수정하게 만들어 개폐 원칙(OCP)을 위반하고 유연성을 떨어뜨립니다.

[테스트 측면] 

결합도가 높기 때문에 테스트 시 가짜 객체(Mock)로 교체하기가 매우 어렵습니다. 또한, 싱글톤 인스턴스가 전역 상태를 공유하므로, 각 단위 테스트가 독립적으로 수행되지 못하고 테스트 순서에 따라 결과가 달라지게 됩니다.

  - **OCP(개폐 원칙, Open-Closed Principle)**: 소프트웨어 요소는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다"는 원칙. <br>싱글톤은 보통 생성자가 `private`이고 인스턴스를 정적으로 고정해서 관리하므로, 상속받아 오버라이딩하거나 인터페이스를 구현해서 갈아끼울 수 없음. 기능을 바꾸려면 기존 클래스의 코드를 직접 수정해야 함 -> 수정에 닫혀있지 않음


**Q. 프레임워크와 라이브러리의 차이를 설명해주세요**

A. 라이브러리는 개발자가 주도권을 가지고 필요할 때 호출하는 도구로, 제어권은 개발자에게 있습니다. 프레임워크는, 프레임워크가 정의한 라이프사이클(규칙)에 따라 개발자가 작성한 코드를 프레임워크가 대신 호출합니다. (ex. 장고가 URL을 분석해 특정 뷰 함수를 실행)
