# 1. 클래스, 객체, 인스턴스 (Class vs Object vs Instance)

- **클래스 (Class)**
  
  객체를 만들기 위한 틀, 설계도
  
  만들어 낼 객체의 데이터(속성)과 행위(메서드)의 집합을 담아놓은 것

- **객체 (Object)**
  
   클래스라는 설계도로부터 만들어진 모든 실체
  
   아직 구체적인 메모리 할당보다는 클래스의 타입으로 선언된 변수 자체에 집중한 표현

- **인스턴스 (Instance)**

  설계도를 바탕으로 실제 메모리(Heap 영역)에 할당된, 런타임에 구동되는 구체적인 실체
  
  "객체는 클래스의 인스턴스다"라고 표현하며, 소속 관계 강조 시 주로 사용

# 2. static 키워드
`고정된`이라는 뜻으로, 클래스 자체에 소속되어 인스턴스(객체)와 무관하게 공통으로 사용되거나, 메모리상에 고정된 상태로 유지되는 변수나 메소드를 정의할 때 사용되는 키워드

- **특징**

  인스턴스가 아닌 클래스 자체에 귀속됨
  
  객체 생성 없이 `클래스명.변수명`으로 접근 가능

- **메모리 구조**

  Heap에 생성되는 일반 변수와 달리, static은 Method 영역에 할당되어 프로그램 종료 시까지 유지됨

- **장점**

  객체간 클래스의 변수, 메서드 등의 데이터 공유가 쉽고, 매번 인스턴스를 생성할 필요가 없어 효율적

- **단점**

  - **메모리 효율**
    선언하자마자 메모리에 올라가므로, 사용 여부와 상관 없이 항상 메모리를 점유
    
    가비지 컬렉터가 메모리를 관리하는 Heap영역과는 달리, Method 영역에 할당되기 때문

  - **객체 지향 위배**
    데이터 캡슐화를 저해하며, 상태를 전역적으로 공유하므로 단위 테스트가 어려워질 수 있음

  - **동시성 이슈**
    멀티스레드 환경에서 여러 객체가 동시 접근 시, 데이터가 오염될 수 있음
    
```java
class Counter {
    static int count = 0; // static 변수: 모든 객체가 공유
    int instanceCount = 0; // 인스턴스 변수: 객체마다 별도 생성

    Counter() {
        count++;
        instanceCount++;
    }
}

public class Main {
    public static void main(String[] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();

        System.out.println(Counter.count);   // 출력: 2 (공유됨)
        System.out.println(c1.instanceCount); // 출력: 1 (개별적)
        System.out.println(c2.instanceCount); // 출력: 1 (개별적)
    }
}
```
  

# 3. 오버로딩과 오버라이딩 (Overloading vs Overriding)
|   | 오버로딩 (Overloading) | 오버라이딩 (Overriding) |
|------|----------------------|------------------------|
| 정의 | 같은 이름의 메서드를 여러 개 정의 | 상위 클래스로부터 상속받은 메서드를 재정의 |
| 조건 | 매개변수의 개수, 타입, 순서가 달라야 함 | 메서드 시그니처(이름, 매개변수, 반환타입) 일치 |
| 시점 | 정적 바인딩 (컴파일 시 결정) | 동적 바인딩 (런타임 시 결정) |
| 장점 | 메서드 이름 오남용 방지, 가독성 향상 | 상속을 통한 일관된 인터페이스 제공 |
|제약 사항|접근 제어자, 반환 타입만 다르게 하는 것은 불가|`final`, `static`, `private` 메서드는 불가|

**`final`, `static`은 오버라이딩이 불가능한 이유**

1. `final` 메서드

    '최종적'이라는 뜻을 가진 키워드. 변경하거나 확장하는 것을 금지한다는 뜻으로, 자식 클래스에서 재정의하는 것을 문법적으로 막음

4. `static` 메서드

    - 오버라이딩은 인스턴스(객체)가 런타임에 어느 것을 사용할지 결정하는 동적 바인딩 방식이지만, `static`은 객체가 생성되기도 전인 컴파일 시점에 클래스에 고정되는 정적 바인딩이 일어남
    - 자식 클래스에서 부모와 같은 이름의 `static` 메서드 선언 시, 오버라이딩되지 않고 단순히 부모의 메서드를 가리는(Hiding) 효과가 발생. 즉, 부모 것은 그대로 있고, 자식 것이 새로 생김
       

```java
class Calculator {
    // 1. 오버로딩: 이름은 같지만 매개변수가 다름
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
}
```

```java
class Animal {
    void sound() { System.out.println("소리를 냅니다."); }
}

class Dog extends Animal {
    // 2. 오버라이딩: 부모의 메서드를 내 식으로 재정의
    @Override
    void sound() { System.out.println("멍멍!"); }
}
```
     
# 4. 추상화 (Abstraction)
복잡한 데이터, 구조, 시스템 등으로부터 불필요한 세부 사항은 숨기고, 핵심적인 공통점만 추출해 모델링하는 과정

코드의 재사용성과 가독성을 높이고, 유지보수 비용을 감소시킴

- **데이터 추상화**

  데이터들의 공통점을 모아 클래스로 정의
  
  차이점은 자식 클래스에 부여해놓고 부모 클래스에서는 추상화
  ex) 강아지, 고양이, 원숭이 → `동물` 클래스

- **프로세스 추상화**

  내부 로직은 감추고 외부에는 기능(인터페이스)만 노출
  
  ex) 데이터베이스가 어떻게 저장하는지는 모르지만, `save()` 메서드로 사용 가능
  
```java
// 추상 클래스: '동물'이라는 개념적 공통점만 정의
abstract class Animal {
    abstract void move(); // 추상 메서드: "움직인다"는 핵심 기능만 정의 (세부 구현 X)
    
    void breathe() { System.out.println("숨을 쉽니다."); } // 공통 기능
}

class Bird extends Animal {
    @Override
    void move() { System.out.println("날개로 날아갑니다."); } // 세부 구현
}

class Fish extends Animal {
    @Override
    void move() { System.out.println("지느러미로 헤엄칩니다."); } // 세부 구현
}
```


# 5. 컴파일러 vs 인터프리터 vs JIT

프로그래밍 언어로 작성된 코드를 컴퓨터가 이해할 수 있는 기계어로 변환하는 과정에 관여하는, 소스 코드 변환 프로그램

- **컴파일러 (Compiler)**
  - **전체 변환**

     소스코드 전체를 읽어 한 번에 기계어로 변환. 변환 과정을 거친 후 생성된 기계어 코드를 싱행
  - **특징**
  
    실행 전 컴파일 시간이 걸리지만, 변환된 코드는 직접 실행되므로 실행 시간은 빠름
    
    코드를 수정했을 때 컴파일 과정이 필요함
  - ex) C, C++, GO, Rust

컴파일이란?
고수준의 소스코드를 전처리, 컴파일러, 어셈블러, 링커의 과정을 거쳐 저수준의 언어로 만들고 실행할 수 있는 프로그램을 만드는 과정

- **인터프리터 언어  (Interpreter)**
  - **한 줄씩 변환**

     소스코드를 한 줄씩 읽어가며 바로 기계어로 변환하고 실행
  - **특징**
  
    컴파일 단계가 없으므로 초기 시작은 빠르지만, 코드를 실행할 때마다 변환 과정을 거치므로, 전체 코드 실행 시간은 컴파일러를 사용할 때보다 느릴 수 있음
    
    코드 수정 시 컴파일 과정이 필요하지 않음
  
  - ex) python

- **JIT(Just-In-Time) 컴파일러 (하이브리드)**
  인터프리터 방식으로 실행하다가, 자주 호출되는 코드(Hot Spot)를 발견하면 이를 기계어로 컴파일하여 캐싱하는, 인터프리터와 컴파일러의 중간 형태
  
  핫 코드에서는 캐싱을 하고 실행하므로 속도가 향상되지만, 컴파일된 코드를 메모리에 저장 후 캐싱하므로 인터프리터 방식에 비해 더 많은 메모리를 소비한다는 단점이 있음

  1. 코드 분석
  실행 시점에 프로그램 코드를 분석하여, 어떤 부분이 자주 실행되는지(hot spot) 판단

  즉, 실행 전 코드 분석 X

  3. 동적 컴파일
  분석 결과에 기반하여, 자주 실행되는 코드(hot spot)만을 선별적으로 기계어로 변환

  핫 코드면 컴파일, 핫 코드가 아니면 인터프리터 방식을 적용
  
  프로그램 실행 중 실시간으로 이루어지는 과정

  5. 최적화
  컴파일 과정에서 다양한 최적화 기법을 적용

  ex) 메모리 접근 패턴을 분석, 가비지 컬렉션의 오버헤드 최소화 등

  7. 실행
  컴파일된 기계어 코드를 실행

  프로그램이 계속 실행되면서 새로운 핫 스팟이 발견되는 경우, 해당 부분도 JIT 컴파일을 통해 최적화
  
  - ex) JVM, .NET, V8(node.js 엔진)
