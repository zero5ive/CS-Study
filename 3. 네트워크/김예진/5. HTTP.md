# HTTP
서버와 클라이언트(브라우저) 간에 **데이터를 주고받기 위한 약속(프로토콜)**

**특징**

**1. 비연결성**

클라이언트가 요청을 보내고 서버가 응답을 마치면 즉시 연결을 끊는 성질.
* **장점**: 서버가 수많은 클라이언트와 연결을 유지하지 않아도 되므로 서버 자원을 아낄 수 있음.
- **단점**: 매번 연결을 새로 맺어야 하는 오버헤드가 발생. (이를 해결하기 위해 HTTP/1.1에서 Keep-Alive가 등장)

**2. 무상태성 (Stateless)**

서버가 클라이언트의 이전 상태(로그인 여부 등)를 기억하지 않는 성질.
- **장점**: 서버가 클라이언트의 상태 정보를 저장할 필요가 없어 서버 확장이 매우 자유로움. 
- **해결**: 상태를 기억해야 하는 경우(로그인 등)에는 쿠키(Cookie), 세션(Session), 토큰(JWT) 등을 활용해 보완.

## HTTP 메시지 구조
클라이언트와 서버가 데이터를 주고받을 때 사용하는 메시지 구조.

|구분|설명|주요 특징|
|--|--|--|
|Header|데이터에 대한 데이터(메타데이터)|`:`으로 구분된 Key-Value 형태. 바디의 정보, 인증, 쿠키 등 포함.|
|Body|실제 전송하는 콘텐츠 본문|HTML, JSON, Image 등 실질적인 데이터가 담김.|

**헤더의 종류**
- **일반 헤더**: 요청 URL, 메서드, 출처의 노출 정도를 정하는 Referrer Policy 등.
- **요청(Request) 헤더**: 클라이언트가 서버에 요청할 때 설정되는 헤더. 클라이언트 정보(OS, 브라우저), 메서드 등 포함.
- **응답(Response) 헤더**: 서버가 클라이언트에게 응답을 보낼 때 설정되는 헤더. 서버 소프트웨어 정보(Nginx 등. 대부분 숨김), 콘텐츠 타입 등 포함.

# HTTP/1.0 vs HTTP/1.1
## HTTP/1.0 (단기 연결)
한 번의 연결당 단 하나의 요청만 처리한다.

**단점**
- 매번 TCP 핸드셰이크가 발생하여 RTT가 증가하고 성능이 저하됨.

## HTTP/1.1 (연결 유지)
**개선점**
1. **Keep-Alive (default)**: 한 번 맺은 TCP 연결을 끊지 않고 계속 사용하여 RTT를 줄임. timeout과 최대 요청수 max를 지정할 수 있음. 

2. **Host 헤더**: 하나의 IP에 여러 호스트(도메인)를 가질 수 있게 됨. 서버는 여러개의 호스트를 가질 수 있으며 이런 유연성을 위해 HTTP/1.1은 헤더에 특정 호스트를 포함할 수 있게 변경. 

3. **대역폭 최적화**: `Range` 헤더를 통해 다운로드가 끊긴 지점부터 재개 가능. 

# HTTP/1.1의 한계: HOL(Head Of Line) Blocking
네트워크 큐에서 **맨 앞 요청이 지연되면 뒤의 요청들도 모두 대기**하게 되는 현상인 HOL(Head Of Line) Blocking이라는 고질적인 성능 저하 문제가 존재한다.

**전통적인 해결책**
- **이미지 스프라이트**: 여러 이미지를 하나로 합침.
- **코드 압축(Minify)**: 공백 제거 등으로 파일 크기 축소.
- **Base64 인코딩**: 이미지를 문자열로 바꿔 HTTP 요청을 할 필요가 없도록 함. (단, 크기는 약 37% 증가).

# HTTP/2
텍스트가 아닌 바이너리 포맷을 사용함. 애플리케이션 계층과 전송 계층 사이에 바이너리 포맷 계층을 추가하여 HTTP 1.0에서처럼 텍스트가 아닌, 더 작은 바이너리 데이터가 프레임으로 캡슐화되어 전송. 

**특징**
- **멀티플렉싱 (Multiplexing)**: 단일 TCP 연결에서 여러 요청/응답을 **비동기적**으로 처리. 리소스를 작은 프레임으로 나누고, 스트림 ID와 청크의 크기를 추가하여 전송하는 것으로 응답 데이터에서 재조립이 가능하게 하여 HOL Blocking을 해결함.
  - 여러 요청을 동시에 보낼 수 있어 요청 수 자체가 성능에 큰 지장을 주지 않음. 이에 따라 HTTP/1.1에서 요청을 줄이기 위해 사용했던 이미지 스프라이트, Base64 인코딩 등의 필요성이 크게 줄어듦.

- **서버 푸시 (Server Push)**: 클라이언트가 요청하지 않아도 서버가 필요한 리소스(CSS, JS 등)를 미리 보내줌.

- **헤더 압축 (HPACK)**: 허프만 인코딩 알고리즘을 사용해 중복 헤더는 전송하지 않도록 하고, 해당 공통 필드로 헤더를 재구성하는 것으로 중복 헤더의 크기를 줄임. 또한 자주 쓰는 헤더를 테이블로 관리하여 인덱스 번호만 전송하도록 함.
  -  허프만 인코딩: 
  문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트수를 사용해 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 전체 데이터 표현에 필요한 비트양을 줄이는 알고리즘.

- **우선순위**: 서버에서 원하는 순서대로 우선순위를 통해 리소스를 전달할 수 있음. 

**한계**: 애플리케이션 계층의 HOL Blocking은 해결했으나, **TCP 계층의 패킷 손실 시 발생하는 HOL Blocking**은 여전히 존재함.

# HTTP/3
HTTP/2의 기반인 TCP의 구조적 한계(연결 지연)를 극복하기 위해 **UDP 기반의 QUIC 프로토콜**을 사용하는 버전.

**특징**

1. **QUIC(Quick UDP Internet Connections) 기반**
   - TCP 기반이 아닌 UDP를 채택하여, 패킷 손실 시 전체 스트림이 멈추는 HOL Blocking 문제를 해결.
   - HTTP/2의 장점(멀티플렉싱 등)을 그대로 유지하면서 전송 속도를 높임.

2. **초기 연결 지연 시간 감소**
   - HTTP/2: TCP 핸드셰이크와 TLS 암호화 핸드셰이크가 각각 별도로 진행되어 연결 설정에 3-RTT 소요.
   - HTTP/3: 연결 설정과 암호화 설정을 단 한 번의 핸드셰이크로 합쳐 1-RTT만에 통신 시작 가능 (이전에 연결했던 서버라면 0-RTT도 가능).

3. **순방향 오류 수정 (FEC, Forward Error Correction)**
   - 패킷 손실이 발생했을 때 재전송을 기다리는 대신, 수신 측에서 에러를 스스로 검출하고 복구하는 매커니즘.

4. **Connection ID**
   - IP가 아닌 고유 ID로 연결을 식별하여, 열악한 네트워크 환경(이동 중 Wi-Fi에서 LTE로 전환 시 등)에서도 끊김 없는 통신이 가능.


# HTTP 상태 코드
클라이언트의 요청에 대해 서버가 처리한 결과를 3자리 숫자로 반환하는 규약. 첫 번째 자릿수는 응답의 성격(Class)을 나타낸다.

## 응답 클래스
|클래스|유형|의미|
|--|--|--|
|1xx|Informational|요청이 수신되었으며 처리가 계속되고 있음|
|2xx|Success|요청이 성공적으로 처리됨|
|3xx|Redirection|요청 완료를 위해 클라이언트의 추가 작업(주소 이동 등)이 필요함|
|4xx|Client Error|클라이언트의 요청에 잘못된 문법이나 권한 등의 문제가 있음|
|5xx|Server Error|서버가 유효한 요청을 처리하는 과정에서 내부 오류가 발생함|

## 주요 상태 코드
### 1xx: 정보
- 100 Continue: 요청을 계속 보낼 것.
 

### 2xx: 성공 (Success)
- 200 OK: 요청이 성공적으로 수행되었으며, 정보가 응답 메시지에 포함됨.

- 201 Created: 요청이 성공적이었으며, 그 결과로 서버에 새로운 리소스가 생성됨. (POST 요청 시 주로 사용)

- 204 No Content: 요청은 성공했으나 응답 본문(Body)에 보낼 데이터가 없음. (성공적인 삭제 처리 시 주로 사용)

### 3xx: 리다이렉션 (Redirection)
- 301 Moved Permanently: 요청한 리소스의 URI가 영구적으로 변경되었음. 이후 요청은 응답에 포함된 새로운 URI로 보내야 함.

- 302 Found: 요청한 리소스의 URI가 일시적으로 변경되었음을 의미함.

### 4xx: 클라이언트 오류 (Client Error)
- 400 Bad Request: 클라이언트가 잘못된 문법으로 요청을 보내 서버가 이해할 수 없음.

- 401 Unauthorized: 해당 리소스에 접근하기 위해 **인증(Authentication)** 절차가 필요함. (ID/PW 등 신원 확인 미비, 즉 인증 오류)

- 403 Forbidden: 서버가 요청을 이해했으나, 리소스에 대한 **접권 권한(Authorization)**이 없어 거절됨. (인가 오류)

- 404 Not Found: 서버가 요청받은 URI에 해당하는 리소스를 찾을 수 없음.

### 5xx: 서버 오류 (Server Error)
- 500 Internal Server Error: 서버 내부의 예기치 못한 오류로 인해 요청을 처리할 수 없음. (코드 에러 등)

- 502 Bad Gateway: 게이트웨이나 프록시 서버가 상위 서버로부터 잘못된 응답을 수신함.

- 503 Service Unavailable: 서버가 과부하 또는 점검으로 인해 일시적으로 요청을 처리할 수 없음.

- 504 Gateway Timeout: 게이트웨이나 프록시 서버가 상위 서버의 응답을 기다리다 제한 시간을 초과함.

# HTTP 메서드 비교
## GET vs POST
|구분|GET|POST|
|--|--|--|
|핵심 목적|리소스 조회 (Read)|리소스 생성 (Create)|
|데이터 전달|URL의 쿼리 스트링(?key=value)|HTTP 메시지 바디 (Body)|
|길이 제한|있음 (브라우저/서버별 약 2KB~8KB)|제한 없음|
|보안성|낮음 (브라우저 기록/URL에 노출)|상대적으로 높음 (Body에 숨김)|
|캐싱|가능 (정적 리소스 공유에 유리)|불가능
멱등성|O (여러 번 실행해도 결과가 같음)|X (실행할 때마다 새 데이터 생성 가능)|

> 패킷 분석(Wireshark 등)을 하면 POST의 Body도 노출되지만, URL에 직접 노출되는 GET보다 1차적인 보안에 유리하다. 따라서 로그인/회원가입은 반드시 POST를 사용해야 한다.

## PUT vs PATCH
데이터를 업데이트한다는 점은 같지만, **'전체 교체'**냐 **'부분 수정'**이냐의 차이가 있다.

**PUT: 리소스 전체 업데이트**
- 요청 시 보낸 데이터로 리소스를 통째로 교체. 
일부 필드만 보내면, 나머지 필드는 null로 덮어씌워지거나 에러가 발생할 수 있음.

- 멱등성: O (같은 요청을 여러 번 보내도 최종 결과는 항상 같다)

**PATCH: 리소스 부분 업데이트**
- 수정이 필요한 특정 필드만 보냄. 
서버 측에서 해당 리소스의 특정 부분만 변경하도록 로직이 구현되어 있어야 함.

- 멱등성: X (구현 방식에 따라 멱등성이 보장되지 않을 수도 있음)

### 예시
기본 데이터: `{"id": 2, "name": "Janet", "email": "janet@reqres.in"}`

- PUT 요청 `({"email": "new@naver.com"})`
  - 결과: `{"id": 2, "email": "new@naver.com"}` 
  (기존의 name 데이터가 삭제/유실될 위험이 있음)

- PATCH 요청 `({"email": "new@naver.com"})`
  - 결과: `{"id": 2, "name": "Janet", "email": "new@naver.com"}` 
  (name은 유지되고 email만 수정됨)

# 퀴즈
**Q. HTTP/2에서 HOL Blocking을 어떻게 해결했나요?**

답변: HTTP/1.1은 한 번에 하나의 요청만 순차적으로 처리하므로 앞선 요청이 늦어지면 뒤가 다 막히는 HOL Blocking이 발생했습니다. 반면, HTTP/2는 리소스를 프레임(Frame) 단위로 쪼개서 하나의 연결 내 여러 스트림으로 비동기 전송하는 멀티플렉싱을 도입하여 애플리케이션 계층에서의 대기 시간을 없앴습니다.

**Q2. HTTP/2가 여전히 'TCP 계층의 HOL Blocking' 문제를 가지는 이유는 무엇인가요?**

답변: HTTP/2는 애플리케이션 계층에서 데이터를 쪼개 보낼 뿐, 전송 계층은 여전히 TCP를 사용하기 때문입니다. TCP는 데이터의 순차적 전달을 보장해야 하므로, 패킷 하나가 손실되면 뒤에 도착한 다른 패킷들이 멀쩡해도 유실된 패킷이 재전송될 때까지 전체 연결이 멈추게 됩니다.

**Q3. HTTP/3가 UDP(QUIC)를 선택함으로써 얻은 이득은 무엇인가요?**

답변: 두 가지가 핵심입니다.

연결 속도: TCP와 TLS 핸드셰이크를 하나로 통합하여 연결 설정을 1-RTT로 줄였습니다.

독립성: UDP 기반의 QUIC은 각 스트림을 독립적으로 처리하므로, 하나의 패킷이 유실되어도 다른 스트림에는 영향을 주지 않아 전송 계층의 HOL Blocking을 해결했습니다.