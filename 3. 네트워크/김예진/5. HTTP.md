# HTTP
서버와 클라이언트(브라우저) 간에 **데이터를 주고받기 위한 약속(프로토콜)**

**특징**

**1. 비연결성**

클라이언트가 요청을 보내고 서버가 응답을 마치면 즉시 연결을 끊는 성질.
* **장점**: 서버가 수많은 클라이언트와 연결을 유지하지 않아도 되므로 서버 자원을 아낄 수 있음.
- **단점**: 매번 연결을 새로 맺어야 하는 오버헤드가 발생. (이를 해결하기 위해 HTTP/1.1에서 Keep-Alive가 등장)

**2. 무상태성 (Stateless)**

서버가 클라이언트의 이전 상태(로그인 여부 등)를 기억하지 않는 성질.
- **장점**: 서버가 클라이언트의 상태 정보를 저장할 필요가 없어 서버 확장이 매우 자유로움. 
- **해결**: 상태를 기억해야 하는 경우(로그인 등)에는 쿠키(Cookie), 세션(Session), 토큰(JWT) 등을 활용해 보완.

## HTTP 메시지 구조
클라이언트와 서버가 데이터를 주고받을 때 사용하는 메시지 구조.

|구분|설명|주요 특징|
|--|--|--|
|Header|데이터에 대한 데이터(메타데이터)|`:`으로 구분된 Key-Value 형태. 바디의 정보, 인증, 쿠키 등 포함.|
|Body|실제 전송하는 콘텐츠 본문|HTML, JSON, Image 등 실질적인 데이터가 담김.|

**헤더의 종류**
- **일반 헤더**: 요청 URL, 메서드, 출처의 노출 정도를 정하는 Referrer Policy 등.
- **요청(Request) 헤더**: 클라이언트가 서버에 요청할 때 설정되는 헤더. 클라이언트 정보(OS, 브라우저), 메서드 등 포함.
- **응답(Response) 헤더**: 서버가 클라이언트에게 응답을 보낼 때 설정되는 헤더. 서버 소프트웨어 정보(Nginx 등. 대부분 숨김), 콘텐츠 타입 등 포함.

# HTTP/1.0 vs HTTP/1.1
## HTTP/1.0 (단기 연결)
한 번의 연결당 단 하나의 요청만 처리한다.

**단점**
- 매번 TCP 핸드셰이크가 발생하여 RTT가 증가하고 성능이 저하됨.

## HTTP/1.1 (연결 유지)
**개선점**
1. **Keep-Alive (default)**: 한 번 맺은 TCP 연결을 끊지 않고 계속 사용하여 RTT를 줄임. timeout과 최대 요청수 max를 지정할 수 있음. 

2. **Host 헤더**: 하나의 IP에 여러 호스트(도메인)를 가질 수 있게 됨. 서버는 여러개의 호스트를 가질 수 있으며 이런 유연성을 위해 HTTP/1.1은 헤더에 특정 호스트를 포함할 수 있게 변경. 

3. **대역폭 최적화**: `Range` 헤더를 통해 다운로드가 끊긴 지점부터 재개 가능. 

# HTTP/1.1의 한계: HOL(Head Of Line) Blocking
네트워크 큐에서 **맨 앞 요청이 지연되면 뒤의 요청들도 모두 대기**하게 되는 현상인 HOL(Head Of Line) Blocking이라는 고질적인 성능 저하 문제가 존재한다.

**전통적인 해결책**
- **이미지 스프라이트**: 여러 이미지를 하나로 합침.
- **코드 압축(Minify)**: 공백 제거 등으로 파일 크기 축소.
- **Base64 인코딩**: 이미지를 문자열로 바꿔 HTTP 요청을 할 필요가 없도록 함. (단, 크기는 약 37% 증가).

# HTTP/2
텍스트가 아닌 바이너리 포맷을 사용함. 애플리케이션 계층과 전송 계층 사이에 바이너리 포맷 계층을 추가하여 HTTP 1.0에서처럼 텍스트가 아닌, 더 작은 바이너리 데이터가 프레임으로 캡슐화되어 전송. 

**특징**
- **멀티플렉싱 (Multiplexing)**: 단일 TCP 연결에서 여러 요청/응답을 **비동기적**으로 처리. 리소스를 작은 프레임으로 나누고, 스트림 ID와 청크의 크기를 추가하여 전송하는 것으로 응답 데이터에서 재조립이 가능하게 하여 HOL Blocking을 해결함.
  - 여러 요청을 동시에 보낼 수 있어 요청 수 자체가 성능에 큰 지장을 주지 않음. 이에 따라 HTTP/1.1에서 요청을 줄이기 위해 사용했던 이미지 스프라이트, Base64 인코딩 등의 필요성이 크게 줄어듦.

- **서버 푸시 (Server Push)**: 클라이언트가 요청하지 않아도 서버가 필요한 리소스(CSS, JS 등)를 미리 보내줌.

- **헤더 압축 (HPACK)**: 허프만 인코딩 알고리즘을 사용해 중복 헤더는 전송하지 않도록 하고, 해당 공통 필드로 헤더를 재구성하는 것으로 중복 헤더의 크기를 줄임. 또한 자주 쓰는 헤더를 테이블로 관리하여 인덱스 번호만 전송하도록 함.
  -  허프만 인코딩: 
  문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트수를 사용해 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 전체 데이터 표현에 필요한 비트양을 줄이는 알고리즘.

- **우선순위**: 서버에서 원하는 순서대로 우선순위를 통해 리소스를 전달할 수 있음. 

**한계**: 애플리케이션 계층의 HOL Blocking은 해결했으나, **TCP 계층의 패킷 손실 시 발생하는 HOL Blocking**은 여전히 존재함.

# HTTP/3
HTTP/2의 기반인 TCP의 구조적 한계(연결 지연)를 극복하기 위해 **UDP 기반의 QUIC 프로토콜**을 사용하는 버전.

**특징**

1. **QUIC(Quick UDP Internet Connections) 기반**
   - TCP 기반이 아닌 UDP를 채택하여, 패킷 손실 시 전체 스트림이 멈추는 HOL Blocking 문제를 해결.
   - HTTP/2의 장점(멀티플렉싱 등)을 그대로 유지하면서 전송 속도를 높임.

2. **초기 연결 지연 시간 감소**
   - HTTP/2: TCP 핸드셰이크와 TLS 암호화 핸드셰이크가 각각 별도로 진행되어 연결 설정에 3-RTT 소요.
   - HTTP/3: 연결 설정과 암호화 설정을 단 한 번의 핸드셰이크로 합쳐 1-RTT만에 통신 시작 가능 (이전에 연결했던 서버라면 0-RTT도 가능).

3. **순방향 오류 수정 (FEC, Forward Error Correction)**
   - 패킷 손실이 발생했을 때 재전송을 기다리는 대신, 수신 측에서 에러를 스스로 검출하고 복구하는 매커니즘.

4. **Connection ID**
   - IP가 아닌 고유 ID로 연결을 식별하여, 열악한 네트워크 환경(이동 중 Wi-Fi에서 LTE로 전환 시 등)에서도 끊김 없는 통신이 가능.

# 퀴즈
**Q. HTTP/2에서 HOL Blocking을 어떻게 해결했나요?**

답변: HTTP/1.1은 한 번에 하나의 요청만 순차적으로 처리하므로 앞선 요청이 늦어지면 뒤가 다 막히는 HOL Blocking이 발생했습니다. 반면, HTTP/2는 리소스를 프레임(Frame) 단위로 쪼개서 하나의 연결 내 여러 스트림으로 비동기 전송하는 멀티플렉싱을 도입하여 애플리케이션 계층에서의 대기 시간을 없앴습니다.

**Q2. HTTP/2가 여전히 'TCP 계층의 HOL Blocking' 문제를 가지는 이유는 무엇인가요?**

답변: HTTP/2는 애플리케이션 계층에서 데이터를 쪼개 보낼 뿐, 전송 계층은 여전히 TCP를 사용하기 때문입니다. TCP는 데이터의 순차적 전달을 보장해야 하므로, 패킷 하나가 손실되면 뒤에 도착한 다른 패킷들이 멀쩡해도 유실된 패킷이 재전송될 때까지 전체 연결이 멈추게 됩니다.

**Q3. HTTP/3가 UDP(QUIC)를 선택함으로써 얻은 이득은 무엇인가요?**

답변: 두 가지가 핵심입니다.

연결 속도: TCP와 TLS 핸드셰이크를 하나로 통합하여 연결 설정을 1-RTT로 줄였습니다.

독립성: UDP 기반의 QUIC은 각 스트림을 독립적으로 처리하므로, 하나의 패킷이 유실되어도 다른 스트림에는 영향을 주지 않아 전송 계층의 HOL Blocking을 해결했습니다.