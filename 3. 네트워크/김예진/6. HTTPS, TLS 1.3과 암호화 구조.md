# HTTPS
`HTTPS = HTTP + 암호화 + 인증 + 완전성 보호` 

HTTP에 암호화나 인증 등의 구조를 더한 것이다.

**특징**

1. 기밀성 (Confidentiality): 도청자가 네트워크 패킷을 가로채도 내용을 알 수 없다. 사용자의 비밀번호, 카드 정보 등을 안전하게 보호한다.

2. 무결성 (Integrity): 데이터가 전송 도중 누군가에 의해 변조되지 않았음을 보장한다. "A에게 1만 원 송금"이 "B에게 1억 원 송금"으로 바뀌는 것을 방지한다.

3. 인증 (Authentication): 접속한 사이트가 진짜 '네이버'인지, 아니면 정보를 빼내기 위한 '피싱 사이트'인지 인증서를 통해 확인할 수 있다.


## HTTP vs HTTPS
||[HTTP (HyperText Transfer Protocol)](https://velog.io/@yejiiiin/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-HTTP)|HTTPS (HTTP over TLS/SSL)|
|--|--|--|
|의미|데이터를 평문으로 전송하는 규약|HTTP에 암호화(TLS) 계층을 더한 규약|
보안성|암호화 없음 (중간에 탈취 시 내용 노출)|데이터 암호화 (가로채도 해독 불가)|
|포트 번호|80번|443번|
|신뢰성|서버의 실체 확인 불가|인증서를 통해 진짜 서버임을 보장|


# 암호화 (대칭/비대칭 암호화)
**암호화**는 평문(plaintext)을 키와 알고리즘 기반으로 암호문(ciphertext)로 바꾸는 과정이며, 데이터의 유출을 방지하고 데이터 무결성을 보장한다.


| 구분 | 대칭 암호화 (Symmetric) | 비대칭 암호화 (Asymmetric) |
| :--- | :--- | :--- |
| **키 개수** | 1개 (비밀 키) | 2개 (공개 키 / 개인 키) |
| **속도** | 매우 빠름 | 상대적으로 느림 |
| **주 목적** | 실제 데이터 전송 암호화 | 인증, 세션 키 교환 |
| **대표 알고리즘** | **AES** (AES-128 등) | **RSA**, **ECDHE** (Diffie-Hellman) |

> **AES (Advanced Encryption Standard)**: 128비트 블록을 4x4 바이트 상태 행렬로 변환하여 스크램블(SubBytes, ShiftRows 등)하는 알고리즘. 
HTTPS 통신에서 실제 데이터를 주고받을 때 주로 사용한다.

# TLS 1.3
TLS(Transport Layer Security)는 SSL의 발전된 버전으로, 현재 웹 보안의 표준이다. 

**특징**
- 기존 2-RTT에서 1-RTT로 핸드셰이크 단축.
- 0-RTT를 지원하여 재연결 시 왕복 시간 없이 즉시 데이터 전송 가능.
- 취약한 RSA 키 교환 방식을 제거하고 ECDHE를 필수화함.

## 0-RTT
한 번 연결했던 기록이 있다면, 다음 접속 시 핸드셰이크 과정 없이 바로 데이터(HTTP Request)를 실어 보낸다. 사용자 입장에서 페이지 로딩 속도가 비약적으로 빨라진다. 재전송 공격에 취약할 수 있어, 서버는 멱등성이 보장되는 요청에 대해서만 허용하는 것이 일반적이다.

## 핸드셰이크 과정

1. **ClientHello**: 
클라이언트가 서버에게 먼저 ClientHello 메시지를 보내며 다음 정보를 보낸다.
   * 지원 가능한 **TLS 버전 목록** 및 **사이퍼슈트(Cipher Suite) 목록**
   * **클라이언트 랜덤값** (난수)
   * **클라이언트 측 ECDHE 공개키** (키 교환을 위해 미리 생성해서 보냄)

2. **ServerHello**: 
서버는 클라이언트의 메시지를 분석하여 **통신 규칙을 결정**한다.
  
   1. **TLS 버전 선택**: 공통 지원 버전 중 가장 높은 버전(TLS 1.3)을 선택.
   2. **사이퍼슈트 선택**: 클라이언트가 제시한 목록 중 서버가 지원 가능한 최적의 암호 제품군을 선택.
   3. **응답 전송**: `ServerHello` 메시지에 다음을 담아 전송한다.
       - **선택된 TLS 버전 및 사이퍼슈트**
       - **서버 랜덤값**
       - **서버 측 ECDHE 공개키**

3. **서버의 추가 메시지 및 검증**: 
   * **Encrypted Extensions**: SNI, ALPN 등 추가 옵션 정보 (암호화됨)
   * **Certificate**: 서버의 공개키가 포함된 **디지털 인증서**
   * **CertificateVerify**: 서버가 인증서에 포함된 공개키의 실제 소유자임을
증명하기 위해, 핸드셰이크 메시지에 대해 개인키로 **전자서명을 수행**
   * **Finished**: 서버 측 핸드셰이크 종료 선언

4. **클라이언트 검증 및 종료**: 
클라이언트는 받은 인증서를 **CA의 공개키로 검증**하여 서버를 신뢰할지 결정한다.

* 양측은 교환한 **ECDHE 공개키들을 조합**하여 실제 데이터를 암호화할 **세션키**를 각자 생성.
* 클라이언트도 **Finished** 메시지를 보내며, 이후 모든 통신은 생성된 세션키(AES)로 보호됨.


# 키 교환 방식의 진화
## RSA 키 교환 (과거 방식)
서버의 공개키를 이용해 클라이언트가 만든 세션키를 전달하는 방식이다.

**과정**: 
  1. 클라이언트가 세션키 생성 
  2. 서버의 공개키로 암호화하여 서버에 전송 
  3. 서버가 자신의 개인키로 복호화하여 키 획득.


**취약점**: 
  - 누군가(해커)가 지금 당장은 암호를 못 풀더라도, **통신 패킷(암호화된 세션키)을 미리 다 저장**해둘 수 있음.
  - 나중에 **서버의 개인키가 유출**된다면 해커는 저장해둔 과거의 패킷들을 모두 열어볼 수 있게 됨.

## 타원곡선 암호화(ECDHE)
과거 RSA 방식에서 서버의 개인키가 유출되면 과거의 모든 통신이 복호화되는 취약점을 해결하기 위해 세션키를 보내지 않고, 양측이 재료만 주고받아 각자 계산하는 방식이다.

### Diffie-Hellman 키 교환 원리
이산로그문제($g^a \pmod p = A$)의 수학적 난해함을 이용한다.

1. 누구나 알 수 있는 공개값($g, p$)을 공유함.
2. 클라이언트는 자신만의 비밀 숫자 $a$, 서버는 $b$를 정함.
3. 클라이언트는 $A = g^a \pmod p$를, 서버는 $B = g^b \pmod p$를 계산해 서로에게 보냄.
4. 결과 (데이터 암호화에 쓰일 세션키): 
   - 클라이언트: $B^a \pmod p = g^{ab} \pmod p$
   - 서버: $A^b \pmod p = g^{ab} \pmod p$

* 양측은 **세션키 그 자체를 전송하지 않는다.**
* 각자의 비밀값과 상대의 공개값을 조합하여 동일한 키를 **각자 계산**한다.
* 통신이 끝나면 사용된 비밀 숫자는 파기되므로, 나중에 서버 키가 털려도 과거 데이터는 안전하다.

> **ECDHE**는 이 원리를 '이산로그문제'보다 훨씬 복잡한 **'타원곡선(Elliptic Curve)'** 수학으로 확장하여, 더 짧은 키로 더 높은 보안성을 구현한다.


# 사이퍼슈트
프로토콜, 암호화 알고리즘, 해싱 알고리즘이 나열된 규약. 암호제품군이라고도 불린다. TLS 1.3에서는 5개를 지원한다.

예시: `TLS_AES_128_GCM_SHA256`

1. TLS: 사용 프로토콜
2. AES_128_GCM: 데이터를 암호화하는 AEAD 사이퍼 모드. (128비트 키의 AES + 병렬 처리가 빠른 GCM 모드)
3. SHA256: 무결성 확인 및 전자서명에 사용할 해싱 알고리즘.

> **AEAD**: 암호화(Encryption)와 인증(Authentication)을 동시에 수행하는 방식. 
데이터가 암호화되었을 뿐만 아니라, 중간에 단 1비트라도 수정되지 않았음을 보장한다.


## 디지털 인증서와 전자서명 검증
### 인증서
사용자가 웹사이트 접속 시, 해당 서버가 신뢰할 수 있는 소유자인지 확인하는 디지털 신분증 역할이다.

예를 들어 사용자가 `https://example.com`에 접속했을 때, 브라우저가 해당 사이트가 정말 `example.com`의 소유자가 운영하는 서버인지 확인하는 데에 쓰이는 것. 도메인 환경에 따라 사용하는 인증서가 다르다.

**구성 요소**: 
`{도메인, 서버공개키, 발급기관(CA), CA의 전자서명}`

**유형**
- 단일 도메인: 단 하나의 주소만 보호 (www.naver.com)
- 와일드카드 (`*`): 해당 도메인의 모든 하위 도메인을 한 번에 보호 (*.naver.com) -> blog.naver.com, mail.naver.com 등 포함.)
- 멀티 도메인 (SAN): 서로 다른 여러 도메인을 하나의 인증서로 묶어서 보호. (www.example.com, mail.example.net, blog.example.org)

### 전자서명
CA가 해당 웹사이트의 신원을 보증하며 찍어준 디지털 위조 방지 도장. 브라우저는 이 도장을 보고 사이트의 진위를 판별한다. 

### 인증서 검증
브라우저가 서버로부터 받은 인증서의 전자서명을 수학적으로 확인하는 과정이다.

**1. 해시값 A 생성**: 브라우저가 받은 인증서 내용(도메인, 공개키 등)을 SHA256으로 직접 돌려 해시값 A를 만든다.

**2. 해시값 B 복원**: 인증서에 붙어있는 '전자서명'을 CA(인증기관)의 공개키로 복호화하여, CA가 보증했던 당시의 해시값 B를 추출한다. 
  - RSA라면 복호화하여 해시값 B를 얻고, ECDSA라면 A와 B의 일치 여부를 확인.

**3. 비교**:
  - A == B:  CA가 인증한 내용과 변함이 없다는 의미 → 신뢰 가능
  - A != B: 누군가 인증서 내용을 바꿨을 가능성 → 위조 위험 


# TLS 1.3 핸드셰이크 요약
> ClientHello와 ServerHello 단계에서
사이퍼슈트와 ECDHE 공개키를 교환하고,
서버 인증서를 검증한 뒤 ECDHE로 공유 비밀을 만든다.
이 공유 비밀을 HKDF로 세션키로 파생하고,
Finished 메시지를 암호화해 교환한 후
이후 모든 통신은 대칭키로 암호화한다.


# 퀴즈
1. 대칭 암호화와 비대칭 암호화의 차이를 설명해보세요.

대칭 암호화는 하나의 비밀 키로 암호화와 복호화를 모두 수행하는 방식으로, 속도가 빠르기 때문에 실제 데이터 전송에 사용됩니다.
반면 비대칭 암호화는 공개키와 개인키 한 쌍을 사용하며, 주로 인증이나 세션키 교환에 사용됩니다.
HTTPS에서는 초기 연결 과정에서 비대칭 암호화를 활용해 안전하게 키를 교환하고, 이후 실제 데이터 통신은 성능이 좋은 대칭 암호화 방식으로 처리합니다.

2. TLS 1.3 핸드셰이크 과정을 간단히 설명해보세요.

TLS 1.3에서는 ClientHello와 ServerHello 단계에서 사이퍼슈트와 ECDHE 공개키를 교환합니다.
서버는 인증서를 보내 자신의 신원을 증명하고, 클라이언트는 이를 CA의 공개키로 검증합니다.
이후 양측은 ECDHE로 동일한 공유 비밀을 계산하고, 이를 HKDF로 세션키로 파생합니다.
Finished 메시지를 암호화해 교환한 뒤, 이후 모든 통신은 이 세션키를 이용한 대칭 암호화로 이루어집니다.

3. 왜 TLS 1.3에서는 RSA 키 교환을 제거하고 ECDHE를 사용하나요?

RSA 키 교환 방식은 서버의 개인키가 유출될 경우, 과거에 캡처된 통신 데이터까지 모두 복호화될 수 있다는 문제가 있습니다.
반면 ECDHE는 세션마다 임시 키를 사용해 공유 비밀을 생성하며, 키 자체를 전송하지 않습니다.
따라서 서버의 장기 개인키가 유출되더라도 과거 통신은 보호되기 때문에 TLS 1.3에서는 ECDHE가 필수로 사용됩니다.