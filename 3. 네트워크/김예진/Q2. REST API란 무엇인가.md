# REST API란?
REST API는 REST 아키텍처 스타일의 설계 원칙을 따르는 애플리케이션 프로그래밍 인터페이스를 뜻한다. 자원을 이름(uri)로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미한다.

## REST API 특징

### 1. Uniform-Interface (인터페이스 일관성)

자원들은 서로 종속적이지 않은 독립적인 인터페이스를 가진다.

- **URL 자원 식별 (identification of resources)**: 자원은 url로 식별되어야 한다.
  - 예: `/books/1`

- **표현을 통한 자원 조작 (manipulation of resources through representations)**: HTTP 메서드(GET, POST, PUT, DELETE)를 통해 자원을 제어한다.

- **Self-descriptive messages**: 메시지 스스로가 자신을 어떻게 처리해야할지 설명하는 것. HTTP Header에 타입을 명시하고 각 메시지(자원)들은 MIME types에 맞추며 정의된 명세를 포함해야 한다. 

  예를 들어 `.json`을 반환한다면 `application/json`으로 명시.

  - 예시
  ```js
  app.get('/bad',(req, res) =>{   
  182 
   
      res.setHeader('content-type', 'application/json'); 
      res.send("메시징메시징") 
  })
  // 이 외에도 JSON 필드명(예: name)이 무엇을 의미하는지(사람 이름인지, 책 제목인지)에 대한 명세(Documentation) 링크나 미디어 타입 정의가 포함되어야 완성된다.

  ```
    
- **HATEOAS (Hypermedia as the Engine of Application State)**:  응답에 **다음 단계로 갈 수 있는 링크**를 포함해야 한다. 클라이언트는 이 링크를 통해 애플리케이션의 상태를 변경한다.

  하이퍼링크에 따라 다른 페이지를 보여줘야 하며, 데이터마다 어떤 URL에서 원했는지 명시해주어야 한다. 보통 href, links, link, url 속성 중 하나에 해당 데이터의 URL을 담아 표기한다.

  - ex1) 동적으로 링크를 만들며 href 속성을 통해 설정
  ```js
  app.get('/books', (req, res) => {  
    const bookCollection = books.map((book) => ({ 
      ...book, 
      links: [{ rel: 'self', href: `/books/${book.id}` }] 
      // rel: relation으로 링크와 요청한 자원과의 관계
      // self : 해당 자원에 대한 링크
    })); 
   
    res.status(200).json(bookCollection); 
  }); 
  ```

  - ex2) link 속성을 기반으로 설정
  ```js
  {"link":http://kundol.net/todos/{id}, "data":[{...}]} 
  ```

>웹 서핑을 할 때 다음 페이지 링크를 눌러 이동하듯, API 응답만 보고도 다음에 할 수 있는 행동(수정, 삭제, 상세조회 등)의 URL을 알 수 있어야 한다.

### 2. Stateless
- 서버는 클라이언트의 상태 (세션 등)을 저장하지 않는다. 

- 각 요청은 독립적이며 요청에 필요한 모든 정보(토큰 등)를 담고 있어야 한다. 서버 확장성(Scalability)이 매우 높아진다.

- HTTP 자체가 Stateless이므로 HTTP를 이용하는 것만으로도 만족된다.


### 3. Cacheable
- HTTP 표준을 그대로 사용하므로 응답 헤더에 Etag, Last-Modified, Cache-Control을 설정하여 자원을 캐싱할 수 있다. 서버 부하를 줄이고 응답 속도를 높인다.

- 이는 HTTP 메서드 중 GET에 한정되며 `Cache-Control:max-age=100(100초)` 같이 시간을 지정할 수 있으며, 캐싱된 데이터가 유효한지 판단하기 위해 `Last-modified`와 `Etag`라는 헤더값을 쓴다.

  - Etag: 전달되는 값에 태그를 붙여 캐싱되는 자원인지 확인하는 것


### 4. Client-Server 구조
- 클라이언트와 서버가 서로 독립적인 구조를 가져야 한다. 
자원을 가진 쪽과 요청하는 쪽의 역할을 명확히 분리하여, 의존성을 줄이고 독립적인 개발을 가능하게 한다.

- HTTP를 통해 가능한 구조이며, HTTP 표준만 지킨다면 웹에서는 그에 따른 화면이 잘 나타나게 된다 서버는 그저 API를 제공하고 그 API에 맞는 비즈니스 로직을 처리하면 되고, 클라이언트 역시 HTTP로 받는 로직만 잘 처리하면 된다.

### 5. Layered System
- 계층 구조로 나뉘어진 아키텍처. 
클라이언트는 서버의 계층(프록시, 게이트웨이 등)을 알 수 없다. 보안 및 구조적 유연성을 제공한다.

- WEB기반 서비스가 보통 이런 구조의 시스템으로 구축된다.

![](https://velog.velcdn.com/images/yejiiiin/post/5ff9b6f8-99db-4b80-b03a-76f44beb2e9c/image.png)

## [추가] Richardson Maturity Model (리처드슨 성숙도 모델)
API가 어느 정도 수준인가에 대한 척도.

- Level 0: HTTP 사용 (하나의 Endpoint에 모든 요청을 보냄)
- Level 1: 개별 자원 식별 (URL 도입)
- Level 2: HTTP 메서드 활용 (GET, POST 등 구분 및 상태 코드 활용) - 대부분의 프로젝트 수준
- Level 3: HATEOAS 도입 (진정한 REST)


## RESTful API URL 설계 규칙
1. 동사가 아닌 명사를 사용하며, 행위는 HTTP 메서드로 표현한다.
   - (X) `POST /books/delete/1'`
   
   - (O) `DELETE /books/1` 



2. 계층 구조를 활용하고 소문자만 사용한다. 너무 길면 하이픈(-)을 쓴다.
   - (O) `/users/1/orders` (1번 유저의 주문 목록)
   - (O) `/api/v1/user-profiles`

3. 파일 확장자를 포함하지 않는다.
   - (X) `/users/1/photo.jpg`
   
   - 헤더의`Accept: image/jpeg` 등을 통해 미디어 타입을 결정한다.

4. 컬렉션(복수) 명사를 권장한다.
   - (O) `/users` (사용자 전체 목록)

5. HTTP 응답 상태코드를 활용하여 처리 결과를 명확히 전달한다. (200, 201, 400, 404 등)

### 예시 1: 도서관 시스템
```js
// 모든 책 조회
app.get('/books') 

// 책 생성
app.post('/books') 

// 특정 책 상세 조회
app.get('/books/:bookid')

// 특정 책 정보 전체 수정 (Replace)
app.put('/books/:bookid') 

// 특정 책 정보 부분 수정 (Update)
app.patch('/books/:bookid')

// 유저가 책을 대여 (관계 형성)
app.post('/users/:userid/books/:bookid/rentals')
```

### 예시 2: 쿼리 스트링과 혼합한 url
검색, 페이지네이션, 정렬 등 매개변수가 많거나 복잡할 경우 쿼리스트링을 함께 사용한다.

- 정렬 및 필터링: `/api/v1/workouts?equipment=barbell&sort=-createdAt`

- 페이지네이션: `/api/v1/posts?page=2&limit=10`
- 버전 관리: URL 앞에 `/v1`, `/v2`를 붙여 하위 호환성을 유지한다.
