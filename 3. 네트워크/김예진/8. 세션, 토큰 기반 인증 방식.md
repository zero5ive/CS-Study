# 배경 (HTTP의 특징)
- [**HTTP의 특징: Stateless**](https://velog.io/@yejiiiin/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-HTTP): 
HTTP 요청을 통해 데이터를 주고받을 때, 요청이 끝나면 요청한 사용자 정보 등을 유지하지 않음

![](https://velog.velcdn.com/images/yejiiiin/post/48350d82-9a81-48cd-beb8-8058d1aadfeb/image.png)

- **문제점**: 페이지를 이동할 때마다 매번 로그인을 다시 해야 함
- **해결**: 서버와 클라이언트가 서로 연결되어 있음을 증명하고자 **세션과 쿠키**를 사용

## 주요 용어
- **세션**: 서버와 클라이언트의 연결이 활성화된 상태
- **세션 ID**: 웹 서버 또는 DB에 저장되는 클라이언트에 대한 유니크한 ID

# 세션 기반 로그인 프로세스
1. **로그인 요청**
2. **세션 ID 생성**: 서버가 유효한 사용자인지 확인 후, 서버의 세션 저장소(메모리 또는 DB)에 세션 ID와 유저 정보를 저장
3. **응답 (Set-Cookie)**: 서버에서 응답 헤더의 `Set-Cookie` 필드에 발급한 세션 ID를 담아 전송
  - 예: `Set-Cookie: JSESSIONID=abc12345; HttpOnly; Secure`
4. **쿠키 저장**: 브라우저는 받은 세션 ID를 쿠키 저장소에 보관
5. **이후 요청**: 클라이언트는 동일한 도메인으로 요청을 보낼 때마다, 헤더에 세션 ID가 담긴 쿠키를 자동으로 포함시킴
6. **검증 및 인가**: 서버는 쿠키의 세션 ID를 자신의 저장소에서 조회하여 신원을 확인하고, 요청한 데이터를 전달

![](https://velog.velcdn.com/images/yejiiiin/post/0e6186d9-dbc5-4202-86a8-9d9150045e4b/image.png)

**단점**
1. 사용자의 상태 데이터를 서버에 저장할 경우, 로그인 중인 유저의 수가 늘어난다면 서버에 **메모리 과부하** 발생
2. RDBMS에 저장할 경우 **직렬화 및 역직렬화**에 대한 오버헤드 발생
3. **서버가 여러 대(Scale-out)**일 경우, 1번 서버에서 로그인한 유저가 2번 서버로 접속하면 세션 정보가 없어 로그인이 풀리는 현상 발생 
  - Sticky Session(특정 유저를 특정 서버에 고정), Session Clustering(세션 공유) 혹은 Redis 같은 외부 세션 저장소를 활용
  
# 토큰 기반 인증 방식(access 토큰, refresh 토큰)

## 배경
- 세션 방식은 서버가 누가 로그인했는지 일일이 기억해야 한다는 단점이 있음
- 즉, 서버가 여러 대일 경우 세션 정보를 공유하기 위해 별도의 DB(Redis 등)이 필요해짐
- **JWT의 전략**: 서버가 기억하지 않고, 필요한 정보를 토큰에 적어서 클라이언트가 들고 있게 한다. 대신 해당 토큰이 진짜인지 확인하는 서명만 추가 

-> state를 모두 토큰 자체만으로 처리하며, 토큰을 처리하는 한 서버를 두고 다른 컨텐츠를 제공하는 서버는 모두 staseless하게 만드는 방식

## JWT란?
JSON Web Token. 
헤더, 페이로드, 서명으로 이루어져있으며, JSON 객체로 인코딩 되며 메시지 인증 및 암호화에 사용됨

- **Header**: 토큰 유형과 서명 알고리즘. base64URI로 인코딩됨   
- **Payload**: 데이터, 토큰 발급자, 토큰 유효기간 등을 포함. base64URI로 인코딩됨. 단순 Base64 인코딩이므로 누구나 열어볼 수 있어 민감 정보 포함 X
- **Signature**: `(인코딩된 header + payload) + 서버의 비밀키`를 기반으로 헤더에 명시된 알고리즘으로 다시 생성한 서명값. 서버가 이를 기반으로 토큰이 진짜인지를 확인

## Access Token & Refresh Token
JWT는 한 번 발급하면 서버가 강제로 뺏을(로그아웃 시키기) 방법이 거의 없음. 이 보안 결함을 해결하기 위해 두 종류의 토큰을 사용한다.

- **Access Token**: 실제 인증에 쓰는 짧은 수명의 토큰 (예: 30분). 털려도 금방 만료되게 함.

- **Refresh Token**: Access Token이 만료되었을 때 새로 발급받기 위한 긴 수명의 토큰 (예: 2주). 보통 DB에 저장하여 관리하며, 보안이 더 중요하다는 특징이 있음.

## 인증 프로세스

1. **로그인 요청**
2. **토큰 발급**: 서버는 Access와 Refresh 토큰을 생성해 전달
3. **요청**: 클라이언트는 요청 시 헤더(Authorization: Bearer <Access_Token>)에 토큰을 실어 보냄
4. **검증**: 서버는 DB 조회 없이 서명(Signature)만 확인하여 즉시 데이터를 제공
5. **갱신**: Access 토큰이 만료되면 Refresh 토큰을 보내 새로운 Access 토큰을 받아옴

![](https://velog.velcdn.com/images/yejiiiin/post/ac1e4ecd-0250-45c1-ba05-ac2ba5e9831f/image.png)

**장점**
- 서버가 상태를 저장하지 않으므로, 서버를 수만 대로 늘려도 인증 처리에 문제가 없음
- 분산 환경에 최적. 여러 도메인(Microservices) 간에 공통된 인증 방식을 쓰기 유리함.

**단점**
- 토큰이 비대해질 경우 네트워크 대역폭에 무리를 줌
- 토큰을 탈취당할 경우 서버가 즉시 폐기 불가 (유효기간을 짧게 두는 것으로 방어)
- 페이로드는 암호화된 게 아니라 단순 인코딩이므로, 민감 정보 포함 불가