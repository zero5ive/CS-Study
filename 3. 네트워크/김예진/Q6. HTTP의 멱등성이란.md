# 멱등성이란?

멱등성(idempotent)이란 여러 번 동일한 요청을 보냈을 때에도 결과(서버의 상태)가 똑같은 성질을 가지는 것을 말한다.

## 멱등성이 중요한 이유
1. 일관성: 반복되는 요청이 단일 요청과 동일한 효과를 갖도록 보장하여, 시스템 전반에 걸쳐 일관된 상태를 유지하게 한다.

2. 유지보수성: 멱등성을 가진 HTTP 메서드로 API로 통신하는 부분에 있어서는 재시도를 처리할 때의 사이드이펙트를 고려한 복잡한 로직을 구현할 필요가 없기 때문에 유지보수성이 증가한다.




# 멱등성을 가지는 메서드


## GET
서버에서 정보를 가져오는 데에 사용되는 메서드. 여러 개의 동일한 GET 요청을 하는 것은 한 번의 요청을 하는 것과 같은 효과를 갖는다.

## HEAD
GET 요청이 생성하는 응답의 헤더를 검색하는 데 사용된다. 리소스 전체를 다운로드하는 오버헤드를 피하고, 어떤 유형의 데이터가 반환되는지, 해당 리소스가 있는지, 수정 날짜 등을 확인하기 위해 쓰인다. GET처럼 서버 상태를 변경하지 않는다.

`curl -I https://example.com/image.png`


## OPTIONS
클라이언트가 서버에 해당 리소스에서 지원하는 HTTP 메서드를 확인하기 위한 요청. 주로 CORS에서 브라우저가 실제 요청을 보내기 전에 수행하는 Preflight 요청에 사용된다.


`curl -X OPTIONS http://localhost:3000/resource -i`


- node.js로 구축한 간단한 option 서버
```js
const express = require('express');
const app = express();
const PORT = process.env.PORT || 3000;
app.options('/resource', (req, res) => {
 res.set({
 'Allow': 'GET, HEAD, OPTIONS',
 'Access-Control-Allow-Methods': 'GET, HEAD, OPTIONS',
 'Access-Control-Allow-Headers': 'Content-Type',
 'Access-Control-Allow-Origin': '*'
 }).end();
});
app.get('/resource', (req, res) => {
 res.status(200).json({"ka" : 1});
});
app.listen(PORT, () => {
 console.log(`Server running on http://localhost:${PORT}`);
});
```

## PUT
리소스를 완전히 다른 버전으로 대체하는 메서드. 요청이 반복되면 동일한 리소스가 다시 대체되어 첫 번째 요청 후와 동일한 상태가 된다.

`age: 20`으로 보내면, 1번 보내든 10번 보내든 결과적으로 그 데이터는 `age: 20`이다.

## DELETE
리소스를 삭제하는 데에 사용되는 메서드. 리소스가 삭제되면 삭제 작업을 반복해도 시스템 상태가 더 이상 변경되지 않는다.

첫 번째 요청은 `204 No Content`(성공), 두 번째는 `404 Not Found`가 뜰 수 있지만, 서버의 상태(데이터가 삭제된 상태)는 변함이 없으므로 멱등하다고 본다.

# 멱등성을 가지지 않는 메서드

## POST
일반적으로 새로운 리소스를 생성하는 데 사용되는 메서드. 여러 POST 요청은 여러 리소스를 생성하는 결과가 나온다.

## PATCH

일반적으로 리소스를 부분적으로 업데이트하는 데 사용되며, 멱등성 여부는 PATCH를 실행하는 방법에 따라 달라진다.

### 멱등한 PATCH 

필드를 특정 값으로 수정하는 것이라면 멱등성을 갖는다. 

- `{"age": 30}`으로 변경 -> 여러 번 해도 30살로 설정

### 멱등하지 않은 PATCH
특정 필드의 값을 증가시키거나 해당 배열에 요소를 추가시키는 것이라면 멱등성을 갖지 않는다.

- `{"operation": "increment", "value": 1}` -> 호출할 때마다 나이가 증가



# 실습 코드

결제처럼 POST임에도 절대 중복 처리되면 안 되는 경우에는 Idempotency-Key를 사용한다.

**작동 메커니즘**
1. 클라이언트: 요청 헤더에 고유한 키(UUID)를 보낸다.

2. 서버: 
- 해당 키를 Redis 같은 저장소에 유효기간과 함께 저장한다.

- 이미 존재하는 키라면, 실제 로직을 수행하지 않고 저장해둔 이전 응답을 그대로 반환한다.

- 처음 보는 키라면, 로직 수행 후 결과를 저장하고 반환한다.

```js
app.post('/order', async (req, res) => {
    const key = req.headers['idempotency-key'];
    
    // 키가 저장소에 있는지 확인
    const cachedResponse = await redis.get(key);
    if (cachedResponse) {
        return res.json(JSON.parse(cachedResponse)); // 이미 처리된 요청이면 바로 응답
    }

    // 실제 비즈니스 로직 (주문 생성 등)
    const result = { status: "success", orderId: "ORD-123" };

    // 결과를 저장소에 기록 (예: 24시간 동안 유효)
    await redis.set(key, JSON.stringify(result), 'EX', 86400);

    res.status(201).json(result);
});
```