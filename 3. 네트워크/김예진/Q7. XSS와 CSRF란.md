# XSS (Cross-Site Scripting)

공격자가 악성 스크립트를 삽입해 **사용자의 브라우저**에서 실행되게 하는 공격.

## 주요 유형

* **Stored XSS**: 공격 스크립트가 서버 DB에 저장되어 불특정 다수에게 노출 (예: 게시판 댓글)
* **Reflected XSS**: URL 파라미터 등에 스크립트를 포함시켜 클릭한 사용자에게 즉시 실행 (예: 검색어에 스크립트 포함)

## 방어 기법

1. **HTML Escaping**: 모든 사용자의 입력값을 텍스트로 처리한다. `<`를 `&lt;`로 변환하여 브라우저가 실행하지 못하게 한다.
2. **HttpOnly Cookie**: 자바스크립트(`document.cookie`)로 쿠키를 읽지 못하게 하여 세션 탈취를 막는다.
3. **CSP (Content Security Policy) 설정**: 허용되지 않은 출처의 스크립트 실행을 브라우저 단에서 차단한다.

---

# CSRF (Cross-Site Request Forgery)

로그인된 사용자의 권한을 이용하여, 사용자가 자신의 의지와 무관하게 **공격자가 의도한 행동**(송금, 비밀번호 변경 등)을 특정 웹사이트에 요청하게 만드는 공격이다.

## 공격 시나리오
1. 사용자가 `bank.com`에 로그인 중.
2. 공격자가 보낸 에어팟 당첨 메일의 링크(`attack.html`) 클릭.
3. 링크 내부의 숨겨진 `<form>`이 `bank.com/transfer`로 자동 제출되어 돈이 빠져나감.


## XSS vs CSRF 차이점

* **XSS**: 사용자의 **정보(쿠키 등)를 탈취**하는 것이 목적.
* **CSRF**: 사용자의 **권한을 도용하여 특정 동작**을 실행하게 하는 것이 목적.

## 방어 기법

1. **CSRF Token**: 서버가 발급한 고유 토큰이 요청에 포함되어야만 정상 요청으로 승인하게 한다. (공격자는 이 토큰을 알 수 없음)
2. **SameSite Cookie**: `Strict`나 `Lax` 설정을 통해 타 사이트에서 발생하는 요청에는 쿠키를 전송하지 않게 한다.
3. **재인증**: 민감한 작업(결제, 비밀번호 변경) 시 비밀번호나 OTP 등을 다시 요구한다.

---

# 실습

## XSS 방지: Escaping 함수
```javascript
function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

```

## CSRF 방지: CSRF Token 적용 (Express)

```javascript
const csurf = require('csurf');
const csrfProtection = csurf({ cookie: true });

app.get('/transfer', csrfProtection, (req, res) => {
  // 클라이언트에 토큰 전달
  res.render('transfer', { csrfToken: req.csrfToken() });
});

app.post('/transfer', csrfProtection, (req, res) => {
  // 토큰이 없거나 일치하지 않으면 자동 에러 발생
  res.send('이체 완료');
});

```
