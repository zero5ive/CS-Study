# 주소창에 URL 입력 시 전체 처리 과정

0. 웹 브라우저에 URL을 입력한다.
1. 웹 브라우저는 요청을 보내기 전, 내부적으로 처리할 수 있는지 확인한다. (리다이렉트나 브라우저 캐시를 확인)
2. 웹 브라우저가 도메인의 IP 주소를 조회한다. (캐시를 찾고 DNS를 검색)
3. 웹 브라우저가 찾은 IP 주소를 기반으로 서버와의 TCP 연결을 시작한다.
4. 웹 브라우저가 HTTP 요청을 서버로 전송한다. (필요한 경우, HTTPS 보안 통신이 진행)
   웹 서버는 요청을 처리하고 응답을 다시 웹 브라우저로 전송한다.
5. 웹 브라우저가 전송 받은 콘텐츠를 렌더링한다.

---

## 1. 요청 준비 및 로컬 검사

브라우저는 네트워크 요청을 보내기 전, 내부적으로 처리할 수 있는 작업이 있는지 확인한다.

### 1-1. URL 파싱

* **URL 파싱**: 프로토콜(HTTP/HTTPS), 도메인, 포트 등을 분석
* **HSTS (HTTP Strict Transport Security)**: HSTS 목록에 해당 도메인이 있다면, 브라우저가 스스로 `http` 요청을 `https`로 변환하여 리다이렉트한다.

### 1-2. 리다이렉트

* 이전에 해당 사이트로부터 `301 Moved Permanently` 응답을 받아 저장된 정보가 있다면, 브라우저는 즉시 새로운 URL로 요청을 변경한다.

### 1-3. 브라우저 캐시 확인 (Private Cache)

* 쿠키, 로컬 스토리지 등을 포함한 캐시로, 브라우저의 **Memory Cache**나 **Disk Cache**를 확인한다.
* `Cache-Control` 헤더를 기준으로 리소스가 유효(Fresh)하다면, 네트워크 요청 없이 캐시 된 값을 그대로 사용하여 화면을 그린다.

---

## 2. DNS (Domain Name Server)

웹 사이트의 도메인 이름과 IP 주소를 서로 변환해주는 시스템. 

로컬 캐시가 없다면 `www.naver.com` 등의 도메인 이름을 컴퓨터가 이해할 수 있는 IP 주소로 변환해야 한다. DNS는 복잡하지만 매우 빨라야 하기 때문에 DNS 데이터는 캐시로 저장해놓는다.

### 2-1. 계층적 캐시 확인

브라우저는 다음 순서대로 IP를 찾는다.

1. **브라우저 캐시** (`chrome://net-internals/#dns`)
2. **OS 캐시** (Hosts 파일, `ipconfig/displaydns`)
3. **라우터 캐시**
4. **ISP(Internet Service Provider, 통신사) DNS 캐시**

### 2-2. 재귀적 쿼리 (Recursive Query)

ISP DNS에도 정보가 없다면, 전 세계에 분산된 DNS 서버들을 순차적으로 방문하여 IP를 찾아낸다.

* **과정**: `Root DNS` → `.com DNS (TLD)` → `naver.com DNS (Authoritative)` → IP 획득

![](https://velog.velcdn.com/images/yejiiiin/post/fd1b5a0e-c367-43fd-a9a6-47db37c6ced7/image.png)


---

## 3. 네트워크 연결 및 공유 캐시

DNS로 획득한 IP를 통해 서버와 연결을 시도한다. 이 과정에서 인터넷망에 존재하는 **공유 캐시(CDN, 프록시)**를 먼저 만날 수 있다.

### 3-1. 프로토콜 연결 수립

웹 브라우저는 웹 서버와 데이터를 주고받기 위해 [TCP 연결](https://velog.io/@yejiiiin/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPIP-4%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%A3%BC%EC%9A%94-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%83%81%EC%84%B8#tcp-transmission-control-protocol)을 맺는다.

* **TCP 3-Way Handshake**: `SYN` → `SYN/ACK` → `ACK` 과정을 거쳐 연결을 수립.
* **[TLS/SSL Handshake (HTTPS)](https://velog.io/@yejiiiin/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TLS-1.3-%ED%95%B8%EB%93%9C%EC%85%B0%EC%9D%B4%ED%81%AC%EC%99%80-%EC%95%94%ED%98%B8%ED%99%94-%EA%B5%AC%EC%A1%B0#tls-13)**: TCP 연결 후  TLS 암호화를 사용하는 통신 세션을 실행하기 위해, 인증서를 검증하고 암호화 키를 교환하는 보안 절차를 수행.

> TCP 연결은 HTTP/2까지 일어나며, HTTP/3(QUIC)은 UDP 기반으로 이 과정을 단축시킬 수 있음

TCP로 연결되면 브라우저와 서버는 [HTTP](https://velog.io/@yejiiiin/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-HTTP)S 프로토콜을 따른다. 

브라우저에서 보내는 HTTP Request에는 요청 라인, 헤더, 본문이 포함된다. 요청 라인에는 GET, POST 등의 요청 메서드, 요청된 리소스의 경로, 통신할 HTTP 버전이 포함돼있다.



### 3-2. 공유 캐시 확인 (CDN / Reverse Proxy)

요청에 대한 응답을 하기 위해, 클라이언트와 원본 서버 사이(Edge)에 위치한 캐시 서버를 먼저 확인한다.

* **CDN (Content Delivery Network)**: AWS CloudFront, Cloudflare 등 전 세계 거점 서버에 콘텐츠를 복사해 둔 것.
* **리버스 프록시 (Nginx)**: 원본 서버 앞단에서 요청을 먼저 받아 캐싱된 데이터가 있으면 바로 반환한다.

![](https://velog.velcdn.com/images/yejiiiin/post/4eaec03e-c9d4-4a82-8e28-a3be20dc297e/image.png)


#### [참고] 프록시 서버의 캐싱 및 처리 과정

1. **최초 방문 시**:
   1. 클라이언트 → 프록시 서버 요청
   2. 프록시 서버가 DNS 조회 후 원본 서버 IP 획득
   3. 원본 서버로부터 콘텐츠 수신 및 **캐싱 정책에 따라 저장**
   4. 클라이언트에게 응답

2. **재방문 시 (짧은 시간 내)**:
   1. 클라이언트 재요청
   2. 프록시 서버 캐시 유효성 확인 (`HIT`)
   3. 캐시가 유효하면 원본 서버 접속 없이 즉시 응답, 그렇지 않다면 원본 서버와 재검증 후 콘텐츠 갱신



---

## 4. 원본 서버 요청 및 처리

만약 공유 캐시에도 데이터가 없다면, 요청은 최종적으로 백엔드 인프라에 도달한다. 

1. **Load Balancer**: 들어온 트래픽을 여러 대의 서버로 분산(L4/L7 스위칭)
2. **Web Server (Nginx/Apache)**: 정적 파일(HTML, CSS, 이미지)을 직접 처리하거나, 동적 요청을 WAS로 넘긴다.
3. **WAS (Web Application Server - Tomcat)**:
   * Spring Boot의 `DispatcherServlet`이 요청을 받는다.
   * Controller → Service → Repository 순으로 비즈니스 로직을 수행한다.
   * **DB 조회**: 데이터베이스에서 필요한 데이터를 가져온다.


4. **HTTP Response 생성**: 처리된 데이터를 바탕으로 응답을 생성하여 반환한다. 
응답에는 상태 라인, 응답 헤더, 리소스(html, css, js 등의 콘텐츠 또는 데이터)가 포함된다.

---

## 5. [브라우저 렌더링](https://velog.io/@yejiiiin/Q.-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95)

서버로부터 받은 데이터를 브라우저가 해석하여 화면에 그린다.

1. **DOM & CSSOM 생성**: HTML과 CSS를 파싱 하여 각각의 트리 구조(객체 모델)를 만든다.
2. **Render Tree 구축**: 실제 화면에 보일 요소만 선별하여 트리를 합친다. (`display: none` 제외)
3. **Layout (Reflow)**: 뷰포트 내에서 각 요소의 정확한 위치와 크기를 계산한다.
4. **Paint & Composite**: 픽셀을 채우고(Paint), 여러 레이어를 합성(Composite)하여 최종 화면을 출력한다.