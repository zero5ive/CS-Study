# CORS란 무엇인가?

## 오리진 (Origin)

오리진은 요청의 **'출처'**를 의미하며, 아래 **3가지 요소가 모두 일치**해야 같은 오리진(Same-Origin)으로 간주된다.

1. **Protocol (Scheme)**: http, https
2. **Host**: naver.com, localhost 등
3. **Port**: :80, :443, :3000 등

> 하나라도 다르면 **Cross-Origin**이다.
> * `https://a.com` vs `http://a.com` (프로토콜 다름 X)
> * `https://a.com` vs `https://api.a.com` (호스트 다름 X)
> * `http://localhost:3000` vs `http://localhost:3001` (포트 다름 X)
> 
> 

---

## SOP (Same-Origin Policy)

브라우저의 기본적인 보안 정책으로, **"같은 오리진끼리만 리소스를 공유할 수 있다"**는 규칙이다.

* **목적**: 악성 스크립트가 사용자의 권한을 이용해 다른 사이트(예: 은행)에 요청을 보내는 **CSRF(Cross-Site Request Forgery)** 공격 등을 방지한다.
* **한계**: 현대 웹은 여러 서비스의 API를 가져다 써야 하므로, SOP만으로는 개발이 불가능합니다. 이를 안전하게 해제해주는 장치가 **CORS**이다.

---

## CORS

CORS는 서버와 브라우저 사이의 **'신뢰 확인 절차'**이다.

### 1. Simple Request (단순 요청)

예비 요청 없이 바로 본 요청을 보낸다. 아래 조건을 모두 만족해야 한다.

* **Method**: GET, HEAD, POST 중 하나.
* **Content-Type**: `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain` 중 하나.

우리가 흔히 쓰는 **`application/json`은 심플 요청이 아니기 때문에** 대부분 Preflight가 발생합니다.

### 2. Preflight Request (예비 요청)

본 요청을 보내기 전, 브라우저가 **OPTIONS** 메서드로 서버에 요청을 보내도 되는지 먼저 물어보는 과정이다.

1. **브라우저**: "나 `https://my.com`인데, `POST`랑 `JSON` 써도 돼?" (OPTIONS 요청)
2. **서버**: "`Access-Control-Allow-Origin: https://my.com`니까 괜찮아!" (응답)
3. **브라우저**: "허락받았으니 진짜 데이터를 보낼게." (본 요청)

2번에서 브라우저의 OPTIONS 요청에 대해 서버는 아래 헤더들을 담아 응답한다.

- Access-Control-Allow-Origin: 허용할 오리진 (보안상 *보다 특정 도메인 명시 권장)
- Access-Control-Allow-Methods: 허용할 HTTP 메서드 리스트 (예: GET, POST, PUT)
- Access-Control-Allow-Headers: 허용할 커스텀 헤더 (예: Authorization, Content-Type)
- Access-Control-Max-Age: Preflight 응답 캐싱 시간. 설정된 시간 동안은 다시 OPTIONS를 보내지 않아 성능이 향상된다.
- Access-Control-Expose-Headers: 브라우저 JS가 응답에서 읽을 수 있도록 허용할 헤더 리스트. (이게 없으면 서버가 보낸 커스텀 헤더를 프론트에서 읽지 못함)

---

## 추가

### CORS는 서버가 아니라 브라우저가 막는 것이다

서버는 요청을 정상적으로 처리하고 200 OK 응답을 보낼 수 있다. 하지만 응답 헤더에 허용된 오리진 정보가 없으면, **브라우저가 그 응답을 파기하고 자바스크립트에 에러를 던진다.** 즉, 서버 로그에는 성공으로 찍히는데 브라우저에서만 에러가 날 수 있다.

### Credentials (인증 정보) 처리

쿠키나 Authorization 헤더를 포함해 요청하려면 추가 설정이 필요하다.

* **Client**: `fetch(url, { credentials: 'include' })`
* **Server**: `Access-Control-Allow-Credentials: true` 응답 필수.
* **주의**: 이때 서버의 `Access-Control-Allow-Origin`은 와일드카드(`*`)를 쓸 수 없고 **반드시 특정 오리진**을 명시해야 한다.

---

## 실습 및 해결 방법

### Express에서 CORS 설정 (Best Practice)


```javascript
const express = require('express');
const cors = require('cors');
const app = express();

const whitelist = ['http://127.0.0.1:3000', 'https://yourdomain.com'];

const corsOptions = {
    origin: function (origin, callback) {
        // origin이 화이트리스트에 있거나, 브라우저 외 요청(origin 없음)일 때 허용
        if (whitelist.indexOf(origin) !== -1 || !origin) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true // 쿠키/인증 허용 시
};

app.use(cors(corsOptions));

app.get('/api', (req, res) => {
    res.json({ data: 'CORS 해결' });
});

app.listen(3001);

```

### 자바/Spring 환경에서의 해결 방법

#### 1. Spring Boot 글로벌 설정 (WebMvcConfigurer)


```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**") // 모든 경로에 대해
                .allowedOrigins("https://my-client-app.com") // 허용할 오리진 명시
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true) // 인증 정보(쿠키/세션) 포함 시 필수
                .maxAge(3600); // 1시간 동안 Preflight 캐싱
    }
}

```

#### 2. Spring Security와의 연동

Spring Security를 사용하면 일반 CORS 설정만으로는 부족하다. **Security Filter**가 CORS 검사보다 먼저 동작하여 요청을 차단할 수 있기 때문이다.

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    // 1. Security 필터 체인에서 CORS 설정을 활성화
    http.cors(Customizer.withDefaults()); 
    
    // 2. CSRF는 API 서버인 경우 보통 비활성화(disable)하지만, CORS와는 별개의 보안 개념임을 인지해야 함
    http.csrf(csrf -> csrf.disable());
    
    return http.build();
}

```

> HttpSecurity 설정에서 cors()를 활성화하고, CorsConfigurationSource를 Bean으로 등록하여 Security 필터 단계에서 CORS 검사가 먼저 이뤄지도록 해야 한다.

---

### 추가 해결 방법: Proxy 서버 이용

서버 간 통신(Server-to-Server)에는 SOP가 적용되지 않는다. 브라우저에서 바로 API 서버로 가지 않고, 내 백엔드 서버(Proxy)를 거쳐서 API 서버와 통신하면 CORS 이슈를 막을 수 있다.





