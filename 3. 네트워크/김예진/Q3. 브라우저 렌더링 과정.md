# 브라우저 렌더링 5단계 (Critical Rendering Path)

브라우저는 브라우저엔진, 렌더링엔진, 네트워크통신부, 자바스크립트 해석기, 
UI백엔드, 자료저장소로 이루어져 있고, 이중 렌더링 엔진이 브라우저 렌더링을 관정한다.

![](https://velog.velcdn.com/images/yejiiiin/post/f9340986-7a5b-4e20-85ca-3d183e445c7c/image.png)

브라우저 렌더링은 렌더링 엔진이 HTML/CSS/JS를 화면에 픽셀로 그리는 과정을 말한다.

1. DOM & CSSOM 트리 구축: HTML을 읽어 구조(DOM)를 만들고, CSS를 읽어 스타일(CSSOM)을 만든다. (동시 진행)

2. 렌더 트리(Render Tree) 생성: 두 트리를 결합하여 실제 화면에 보일 노드만으로 구성된 트리를 만든다.
   - display: none은 제외되지만, visibility: hidden은 포함

3. 레이아웃(Layout/Reflow): 각 노드가 화면의 어느 위치에 어느 크기로 배치될지 계산한다.

4. 페인트(Paint): 계산된 위치에 실제 색상, 그림자, 글꼴 등을 칠한다. (레스터화)

5. 레이어 합치기(Composite): 분리된 레이어들을 순서대로 합쳐 최종 화면을 출력한다

> 렌더트리와 DOM 트리는 1:1 대응되지 않는다. DOM트리 > 렌더객체 > 렌더트리가 되는 과정에서 display:none으로 사라지는 렌더 객체(노드)들이 있을 수 있기 때문에 1 : 1 대응이 아니다. 

## [추가] 성능 최적화: SSR vs CSR

백엔드 개발자는 단순히 데이터를 주는 것을 넘어, 어떤 방식으로 화면을 구성할지에 따라 서버의 역할이 달라진다.

|비교 항목|SSR (Server-Side Rendering)|CSR (Client-Side Rendering)|
|--|--|--|
|렌더링 주체|서버 (서버에서 HTML을 완성해서 보냄)|브라우저 (빈 HTML+JS를 보내면 브라우저가 그림)|
|초기 로딩 (FCP)|빠름 (사용자는 즉시 완성된 화면을 봄)|느림 (JS 파일을 다 받고 실행해야 화면이 보임)|
|서버 부하|높음 (모든 요청마다 서버가 HTML을 생성)|낮음 (서버는 JSON 데이터만 보내면 됨)|
|SEO (검색 엔진)|유리함 (완성된 HTML이라 크롤링이 쉬움)|불리함 (JS 실행 전에는 빈 페이지로 보임)|
|TTV vs TTI|TTV(보이는 시점)와 TTI(상호작용) 간 차이 발생 가능|TTV와 TTI가 거의 동시에 발생|

> 백엔드 영역에서는 "사용자가 첫 화면을 빨리 봐야 하는가(SSR)?"와 "서버 자원을 아끼고 유연한 앱 경험을 줄 것인가(CSR)?"를 고민하게 된다.

### SSR의 데이터 패칭 전략
- 서버에서 HTML을 만들 때 외부 API 호출이 늦어지면 사용자는 빈 화면을 오래 보게 된다.

- 이를 해결하기 위해 **캐싱(Redis 등)**이나 병렬 데이터 페칭을 활용할 수 있다.
