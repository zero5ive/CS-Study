# HTTP 헤더(header)
![](https://velog.velcdn.com/images/shypanda0119/post/891dc6d3-7e16-4462-95da-7f0309337ba6/image.png)
헤더는 콜론 ':'으로 서로 구분되는 key-value 형태로 설정
HTTP요청을 할 때 3가지의 헤더인 일반헤더, 요청헤더, 응답헤더가 자동으로 생기며, 서버에서 설정하는 헤더를 응답헤더, 클라이언트에서 설정한 헤더를 요청헤더라고 함

#### 일반헤더란?
요청한 URL, 요청메서드, 해당 자원을 요청할 때 해당자원의 출처를 나타내는 URL을 노출시킬지 말지를 정하는 보안정도가 설정되어있는 Refferer POlicy 등이 들어감

#### 요청헤더란?
클라이언트가 서버에 요청할 때 클라이언트가 설정하는 또는 자동으로 설정되는 헤더를 말하며 요청 헤더에는 메서드, 클라이언트 OS, 브라우저 정보 등이 담김

#### 응답헤더란?
서버가 클라이언트에게 응답을 보낼 때 설정하는 또는 자동으로 설정되는 헤더를 말하며 응답 헤더에는 서버의 소프트웨어 정보 등이 담김

# HTTP/1.0 VS HTTP/1.1, keep-alive, HOL

#### HTTP/1.0이란?
수명이 짧은 연결이며, HTTP요청은 자체 요청에서 완료가 됨. 각 HTTP 요청당 TCP 핸드셰이크가 발생되며 기본적으로 한 연결당 하나의 요청을 처리하도록 설계됐으며, 한번 연결할 때마다 TCP연결을 계속해야 하니 RTT가 늘어나는 문제점이 있음

[참고] RTT(Round Trip Time: 왕복 지연시간)란?
신호를 전송하고 해당 신호의 수신확인에 걸린 시간을 더한 값이자 어떤 메시지가 두 장치 사이를 왕복하는데 걸린 시간
![](https://velog.velcdn.com/images/shypanda0119/post/36870e94-b27d-40f7-bed9-9d8114b5acd2/image.png)

#### HTTP/1.1이란?
HTTP/1.0의 단점을 보완한 프로토콜이며 3가지 차이점이 있음

1. keep-alive default
매번 데이터를 요청할 때 마다 TCP 연결을 하는ㄱ ㅔ아닌 한번 해놓고 계쏙해서 데이터를 받을 수 있게 만듬
![](https://velog.velcdn.com/images/shypanda0119/post/a83d0b14-bc33-45a5-92f5-ad5addc42820/image.png)
- keep-alive header
TCP연결을 유지하는 것을 알려주는 헤더로 연결유지시간인 timeout과 최대 요청수 max를 정할 수 있으며, node.js에서는 연결유지시간인 timeout 시간만을 지정할 수 있음

2. 호스트 헤더
HTTP/1.0은 서버가 하나의 호스트만 가진다고 가정하기 때문에 HTTP/1.0은 헤더에 호스트를 포함하지 않았고 이 때문에 HTTP/1.0은 하나의 IP에 하나의 호스트만 가질 수 있음
그러나, 서버는 여러개의 호스트를 가질 수 있기 때문에 이런 유연성을 위해 HTTP/1.1은 헤더에 특정 호스트를 포함할 수 있게 변경됐고 항항상 호스트를 포함해서 요청하도록 바뀜

3. 대역폭 최적화
HTTP/1.0의 경우 어떠한 파일을 다운로드 받다가 연결이 끊기면 다시 다운로드 받는 것은 불가능
HTTP/1.0에서는 10KB 파일을 다운로드 받는다고 했을 때 5KB까지만 받고 다시 다운로드를 받는게 불가능했지만 이를 HTTP/1.1에서는 Range:bytes=5000- 라는 헤더를 추가해서 다운로드 재개 요청을 할 수 있음

### 요청을 줄이기 위한 기술
HTTP/1.1로 발전했음에도 불구하고 서버요청을 할 때마다 RTT는 계쏙 증가하기 떄문에 요청을 줄이기 위한 여러가지 기술들이 있음
대표적으로 이미지스프라이트(image sprite), 코드압축, Base64 인코딩 기술들이 있음

#### 이미지 스프라이트
수많은 이미지를 하나의 이미지로 만들어 하나의 이미지만 다운받아놓고 이를 통해 수많은 이미지를 다운받는 듯한 효과를 내는 것

#### 코드압축
코드를 압축해서 서빙

#### 이미지 Base64 인코딩
이미지 파일을 64진법으로 이루어진 문자열로 인코딩해서 이미지 서버에 대한 HTTP 요청을 할 필요가 없이 만드는 것. 하지만, Base64 인코딩을 할 경우 파일크기가 37퍼센트 더 커지는 단점이 있음

### HTTP/1.1의 고질적인 문제: HOL
HOL과 무거운 헤더를 가지는 문제점이 있었고, 이를 해결하지 못함

#### HOL(Head Of Line Blocking)이란?
네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능저하현상
![](https://velog.velcdn.com/images/shypanda0119/post/d8ce1cf6-a445-4a47-a692-1a5a36d22c9c/image.png)


### HTTP/2와 HTTP/3의 차이

### 바이너리 포맷 계층
애플리케이션 계층과 전송 계층 사이에 바이너리 포맷 계층을 추가. HTTP 1.0은 일반 텍스트 메시지를 전송하고 줄 바꿈으로 데이터를 나눴다면 HTTP 2.0은 0과 1로 이루어진 바이너리 데이터로 변경되었고 더 작은 메시지가 프레임으로 캡슐화 되어서 전송
![](https://velog.velcdn.com/images/shypanda0119/post/5752692a-005d-4230-9cc3-a85327b2a74f/image.png)

[참고] h2와 h2c
HTTP/2는 TLS를 선택적으로 쓸 수 있음. 즉, TLS가 없는 HTTP/2도 존재
- h2c는 TLS를 사용하지 않고 TCP 연결 위에서 직접 HTTP/2를 사용하는 것을 의미. 개발 환경에서의 디버깅이나 로컬 테스트를 위해 암호화된 연결을 설정할 필요가 없으므로 개발자들이 편리하게 테스트를 할 수 있다는 장점, 암호화와 관련된 오버헤드가 없다는 장점  
- h2는 tls가 장착된 http2를 부르며 브라우저에서는  HTTPS가 없는 HTTP2는 지원하지 않기 때문에  브라우저에서는 h2c가 아니라 h2만 허용됩니다.   

### 멀티플렉싱
단일 TCP 연결의 여러 스트림에서 여러 HTTP 요청과 응답을 비동기적으로 보낼 수 있음. 이를 통해 HOL을 해결
HTTP/1.1에서는 병렬요청을 하려면 다중 TCP연결을 통해서 하고 일반적으로는 TCP 연결하나당 병렬요청은 불가능
이를 HTTP/2.0에서는 리소스를 작은 프레임으로 나누고 이를 스트림으로 프레임을 전달

### 서버푸시
서버가 리소스를 클라이언트에 푸시를 할 수 있음. 요청된 html 파일과 함께 다른 개체를 별도로 보낼 수 있으며, 만약 html에 css가 포함돼있다면 별도 요청없이 css를 같이 보낼 수 있음

### 헤더압축
HTTP/1.1에서는 무거운 헤더가 있었지만 이를 허프만 인코딩 압축 방법 등으로 압축시킴. 똑같은 서버에서 2개의 이미지를 준다고 했을 때 중복되는 헤더는 제외한채 보내고 해당 공통 필드로 헤더를 재구성하며 중복되지 않은 헤더값은 허프만 인코딩 압축 방법으로 압축해 전송

### 우선순위
서버에서 원하는 순서대로 우선순위를 정해 리소스를 전달

# HTTP/3
 HTTP/2는 여전히 TCP를 사용하기 때문에 초기 연결에 대한 RTT로 인한 지연시간이라는 문제점이 있었고 이를 해결한 버전.
- QUIC(Quick UDP Internet Connections)이라는 계층 위에서 돌아가며, TCP 기반이 아닌 UDP 기반으로 돌아가며 HTTP/2에서 장점이었던 멀티플렉싱 등을 가지고 있으며 초기 연결설정시 지연시간 감소라는 대표적 특성을 가짐
- HTTP/2의 경우 3 - RTT가 필요했다면 QUIC은 1 - RTT만 필요하다는 장점 있음
- HTTP/2의 경우 클라이언트와 서버간의 연결을 맺어 세션을 만드는데 필요한 핸드셰이크, 암호화통신을 구축하기 위한 TLS 핸드셰이크가 각각 필요
그러나 HTTP/3은 TLS로 암호화 통신을 구축할 때의 단 한번의 핸드셰이크를 활용해 클라이언트와 서버간의 연결, 암호화 통신 모두 다 구축을 하기에 1 - RTT만에 모든 연결을 성립할 수 있음
- 전송된 패킷이 손실 됐다면 수신측에서 에러를 검출하고 수정하는 방식이며 열약한 네트워크 환경에서도 낮은 패킷손실률을 자랑하는 순방향 오류 수정 메커니즘(FEC, Forward Error Correction)이라는 특징을 가짐

