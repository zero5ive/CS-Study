# 세션기반인증방식
로그인은 세션기반인증방식 또는 토큰기반인증방식으로 구현

HTTP의 특징 중 하나는 상태없음(stateless) 특징이 있는데, HTTP 요청을 통해 데이터를 주고 받을 때 요청이 끝나면 요청한 사용자의 정보 등을 유지하지 않는 특징을 가지고 있음
![](https://velog.velcdn.com/images/shypanda0119/post/f91b448c-e891-4766-bbfe-6c63df8bdd92/image.png)
이렇기 때문에 로그인 상태를 유지하는 것은 힘들기 때문에 세션과 세션ID가 필요함
- 세션 : 서버와 클라이언트의 연결이 활성화 된 상태를 의미
- 세션ID : 웹 서버 또는 DB에 저장되는 클라이언트에 대한 유니크한 ID

## 세션기반 로그인 프로세스
1. 처음 로그인 >> 세션 ID가 생성 >> 서버에서 세션ID를 쿠키로 설정해서 클라이언트에게 전달
2. 클라이언트가 서버에 요청을 보낼 때 해당 세션ID를 쿠키로 담아서 전에 로그인했던 아이디인지 확인
3. 로그인 유지

**[단점]**
1. 사용자의 상태에 관한 데이터를 서버에 저장했을 때 로그인 중인 유저의 수가 늘어난다면 서버의 메모리 과부하가 일어날 수 있음
2. DB 중 RDBMS에 저장한다면 직렬화 및 역직렬화에 관한 오버헤드 발생


## 토근기반인증방식(access토큰, refresh토큰)
state를 모두 토큰 자체만으로 처리하며 토큰을 처리하는 한 서버를 두고 다른 컨텐츠를 제공하는 서버는 모두 stateless하게 만들기

### JWT토큰
1. 인증로직 >> JWT토큰생성(access 토큰, refresh 토큰)
2. 사용자가 이후에 access 토큰을 HTTP Header - Authorization 또는 HTTP Header - Cookie에 담아 인증이 필요한 서버에 요청해 원하는 컨텐츠를 가져옴
![](https://velog.velcdn.com/images/shypanda0119/post/1b79f998-125a-4cc2-8061-e17ff015f964/image.png)

#### JWT(JSON Web Token)란?
헤더, 페이로드, 서명으로 이루어져 있으며 JSON 객체로 인코딩되며 메시지 인증, 암호화에 사용

![](https://velog.velcdn.com/images/shypanda0119/post/a016e559-06b3-4f91-aba3-fcee949ac687/image.png)
Header - 토큰 유형과 서명알고리즘, base64URL로 인코딩
Payload - 데이터, 토큰 발급자, 토큰 유효기간, base64URI로 인코딩
Signature - (인코딩된 header + payload) + 비밀키를 기반으로 헤더에 명시된 알고리즘으로 다시 생성한 서명값.

**[장점]**
1. 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요 없음
2. 다른 유형의 토큰과 비교했을 때 경량화 돼있음. SAML(Security Assertion Markup Language Tokens)이란 토큰이 있지만 이에 비해 훨씬 경량화 돼있음.
3. 디코딩했을 때 JSON이 나오기 때문에 JSON을 기반으로 쉽게 직렬화, 역직렬화가 가능

**[단점]**
1. 토큰이 비대해질 경우 당연히 서버과부화에 영향을 줄 수 있음
2. 토큰을 탈취당할 경우 디코딩했을 때 데이터를 볼 수 있음


## 토큰기반인증방식(access토큰, refresh 토큰) 
refresh토큰과 access토큰 두개를 기반으로 구현하며 access 토큰의 수명은 짧게, refresh 토큰의 수명은 길게 함
refresh 토큰은 access 토큰이 만료됐을 때 다시 access 토큰을 얻기 위해 사용되는 토큰이며, 이를 통해 access 토큰이 만료됐을때마다 인증에 관한 비용이 줄어듬

 ![](https://velog.velcdn.com/images/shypanda0119/post/c1ac9d4b-ba8c-4276-a626-fb7db4688a5c/image.png)
access 토큰이 만료되거나 사용자가 새로고침을 할 때 refresh토큰을 기반으로 새로운 access token을 얻음
 
 ![](https://velog.velcdn.com/images/shypanda0119/post/7fc0a9db-8f24-4ff3-bfd8-035cccb128a7/image.png)

### 주의할 점
이렇게 access 토큰을 얻었다면 그 이후에 요청을 할 때는 HTTP Header - Authorization 또는 HTTP Header - Cookie에 담아 요청을 하게 됨

**[규칙]**
- Authorization 헤더에 `Bearer <token>` 형식으로 토큰을 전달하여,
  토큰 기반 인증 방식임을 서버에 명시한다.
- https를 사용해야 함
- 쿠키에 저장한다면 sameSite: "Strict"를 쓰기
- 수명이 짧은 access token을 발급
- url에 토큰을 전달하지 말아야 함
  
**참고로 이러한 점들은 OAuth2.0과 JWT에 관한 표준문서인 RFC 6750, RFC7519를 기반으로 함**
  
### 토큰을 탈취당하는 것을 대비하는 방법
1. 먼저 Access Token의 수명을 짧게 설정하여 탈취된 토큰의 유효 기간을 최소화. 짧은 수명의 Access Token을 사용하고, 필요할 때만 Refresh Token을 통해 새로운 AccessToken을 발급 받음
2. Refresh Token을 사용하여 민감한 작업을 수행하려고 할 때 추가적인 사용자 인증 단계를 요구 ex) IP주소, 디바이스 정보등을 이용하거나 google authentifactor를 이용한 2단계 인증을 사용
3. 쿠키에 HttpOnly 및 Secure을 걸어서 관리

